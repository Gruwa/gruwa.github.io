webpackJsonp([0],[
/* 0 */
/***/ (function(module, exports) {

eval("module.exports = undefined;\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"jQuery\",\"amd\":\"jQuery\",\"root\":\"$\"}\n// module id = 0\n// module chunks = 0\n\n//# sourceURL=webpack:///external_%7B%22commonjs%22:%22jQuery%22,%22amd%22:%22jQuery%22,%22root%22:%22$%22%7D?");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// see:\n// http://ejohn.org/blog/javascript-micro-templating/\n\n// Simple JavaScript Templating\n// John Resig - http://ejohn.org/ - MIT Licensed\n\nvar cache = {};\n\nfunction tmpl(str, data) {\n    // Figure out if we're getting a template, or if we need to\n    // load the template - and be sure to cache the result.\n    var fn = !/\\W/.test(str) ? cache[str] = cache[str] || tmpl(document.getElementById(str).innerHTML) :\n\n    // Generate a reusable function that will serve as a template\n    // generator (and which will be cached).\n    new Function(\"obj\", \"var p=[],print=function(){p.push.apply(p,arguments);};\" +\n\n    // Introduce the data as local variables using with(){}\n    \"with(obj){p.push('\" +\n\n    // Convert the template into pure JavaScript\n    str.replace(/[\\r\\t\\n]/g, \" \").split(\"<%\").join(\"\\t\").replace(/((^|%>)[^\\t]*)'/g, \"$1\\r\").replace(/\\t=(.*?)%>/g, \"',$1,'\").split(\"\\t\").join(\"');\").split(\"%>\").join(\"p.push('\").split(\"\\r\").join(\"\\\\'\") + \"');}return p.join('');\");\n\n    // Provide some basic currying to the user\n    return data ? fn(data) : fn;\n};\n\nmodule.exports = tmpl;\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/routes/template.js\n// module id = 1\n// module chunks = 0\n\n//# sourceURL=webpack:///./js/routes/template.js?");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = function myscript() {\n    var serverData = __webpack_require__(8);\n    var template = __webpack_require__(1);\n    var templateScript = __webpack_require__(9);\n    var bxslider = __webpack_require__(6);\n    var masonry = __webpack_require__(7);\n\n    // masonry()\n    bxslider();\n\n    $(function () {\n        if (true) {\n            debugger;\n        }\n\n        var $jsData = JSON.parse(serverData);\n        var $html = templateScript;\n        var $dataTmpl = {\n            $data: $jsData\n        };\n        var $content = template($html, $dataTmpl);\n\n        $('#partners--template__in').html('');\n        $('#partners--template__in').append($content);\n\n        bxslider($('.bxslider').bxSlider());\n\n        // $('.grid').masonry({\n        //     itemSelector: '.grid-item',\n        //     columnWidth: 200\n        // })\n    });\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/routes/myscript.js\n// module id = 2\n// module chunks = 0\n\n//# sourceURL=webpack:///./js/routes/myscript.js?");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = function pixabay() {\n\n    var template = __webpack_require__(1);\n\n    $(function () {\n        'use strict';\n\n        if (true) {\n            debugger;\n        }\n\n        var $value = randWDclassic(1);\n\n        function randWDclassic(n) {\n            var s = '';\n            var abd = 'abcdefghijklmnopqrstuvwxyz';\n            var aL = abd.length;\n            while (s.length < n) {\n                s += abd[Math.random() * aL | 0];\n            }return s;\n        };\n\n        $.ajax({\n            url: 'https://pixabay.com/api/',\n            method: 'GET',\n            dataType: 'jsonp',\n            data: {\n                key: '5069177-dbb9700ef5f333933be917c5e',\n                q: $value,\n                image_type: 'photo',\n                callback: 'ServerPhotoCallback',\n                per_page: 7,\n                category: 'travel',\n                min_width: 200\n            }\n        });\n\n        window.ServerPhotoCallback = function ($data) {\n\n            if (true) {\n                debugger;\n            }\n\n            var $html = $('#activity--bar-out').html();\n            // let $html = templateBingImg\n            var $dataTmpl = {\n                $data: $data\n            };\n            var $SearchContent = template($html, $dataTmpl);\n\n            $('#activity--bar-in').html('');\n            $('#activity--bar-in').append($SearchContent);\n        };\n\n        $('form').submit(function (event) {\n\n            if (true) {\n                debugger;\n            }\n\n            event.preventDefault();\n            $value = $('#activity--search').val();\n            $.ajax({\n                url: 'https://pixabay.com/api/',\n                method: 'GET',\n                dataType: 'jsonp',\n                data: {\n                    key: '5069177-dbb9700ef5f333933be917c5e',\n                    q: $value,\n                    image_type: 'photo',\n                    callback: 'ServerPhotoCallback',\n                    per_page: 7,\n                    category: 'travel',\n                    min_width: 200\n                }\n            });\n        });\n    });\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/routes/pixabay.js\n// module id = 3\n// module chunks = 0\n\n//# sourceURL=webpack:///./js/routes/pixabay.js?");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

eval("module.exports = undefined;\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"lodash\",\"amd\":\"lodash\",\"root\":\"_\"}\n// module id = 4\n// module chunks = 0\n\n//# sourceURL=webpack:///external_%7B%22commonjs%22:%22lodash%22,%22amd%22:%22lodash%22,%22root%22:%22_%22%7D?");

/***/ }),
/* 5 */,
/* 6 */
/***/ (function(module, exports) {

eval("module.exports = function bxslider() {\n\n  /**\r\n   * bxSlider v4.2.12\r\n   * Copyright 2013-2015 Steven Wanderski\r\n   * Written while drinking Belgian ales and listening to jazz\r\n   * Licensed under MIT (http://opensource.org/licenses/MIT)\r\n   */\n\n  ;(function ($) {\n\n    var defaults = {\n\n      // GENERAL\n      mode: 'horizontal',\n      slideSelector: '',\n      infiniteLoop: true,\n      hideControlOnEnd: false,\n      speed: 500,\n      easing: null,\n      slideMargin: 0,\n      startSlide: 0,\n      randomStart: false,\n      captions: false,\n      ticker: false,\n      tickerHover: false,\n      adaptiveHeight: false,\n      adaptiveHeightSpeed: 500,\n      video: false,\n      useCSS: true,\n      preloadImages: 'visible',\n      responsive: true,\n      slideZIndex: 50,\n      wrapperClass: 'bx-wrapper',\n\n      // TOUCH\n      touchEnabled: true,\n      swipeThreshold: 50,\n      oneToOneTouch: true,\n      preventDefaultSwipeX: true,\n      preventDefaultSwipeY: false,\n\n      // ACCESSIBILITY\n      ariaLive: true,\n      ariaHidden: true,\n\n      // KEYBOARD\n      keyboardEnabled: false,\n\n      // PAGER\n      pager: true,\n      pagerType: 'full',\n      pagerShortSeparator: ' / ',\n      pagerSelector: null,\n      buildPager: null,\n      pagerCustom: null,\n\n      // CONTROLS\n      controls: true,\n      nextText: 'Next',\n      prevText: 'Prev',\n      nextSelector: null,\n      prevSelector: null,\n      autoControls: false,\n      startText: 'Start',\n      stopText: 'Stop',\n      autoControlsCombine: false,\n      autoControlsSelector: null,\n\n      // AUTO\n      auto: false,\n      pause: 4000,\n      autoStart: true,\n      autoDirection: 'next',\n      stopAutoOnClick: false,\n      autoHover: false,\n      autoDelay: 0,\n      autoSlideForOnePage: false,\n\n      // CAROUSEL\n      minSlides: 1,\n      maxSlides: 1,\n      moveSlides: 0,\n      slideWidth: 0,\n      shrinkItems: false,\n\n      // CALLBACKS\n      onSliderLoad: function onSliderLoad() {\n        return true;\n      },\n      onSlideBefore: function onSlideBefore() {\n        return true;\n      },\n      onSlideAfter: function onSlideAfter() {\n        return true;\n      },\n      onSlideNext: function onSlideNext() {\n        return true;\n      },\n      onSlidePrev: function onSlidePrev() {\n        return true;\n      },\n      onSliderResize: function onSliderResize() {\n        return true;\n      }\n    };\n\n    $.fn.bxSlider = function (options) {\n\n      if (this.length === 0) {\n        return this;\n      }\n\n      // support multiple elements\n      if (this.length > 1) {\n        this.each(function () {\n          $(this).bxSlider(options);\n        });\n        return this;\n      }\n\n      // create a namespace to be used throughout the plugin\n      var slider = {},\n\n      // set a reference to our slider element\n      el = this,\n\n      // get the original window dimens (thanks a lot IE)\n      windowWidth = $(window).width(),\n          windowHeight = $(window).height();\n\n      // Return if slider is already initialized\n      if ($(el).data('bxSlider')) {\n        return;\n      }\n\n      /**\r\n       * ===================================================================================\r\n       * = PRIVATE FUNCTIONS\r\n       * ===================================================================================\r\n       */\n\n      /**\r\n       * Initializes namespace settings to be used throughout plugin\r\n       */\n      var init = function init() {\n        // Return if slider is already initialized\n        if ($(el).data('bxSlider')) {\n          return;\n        }\n        // merge user-supplied options with the defaults\n        slider.settings = $.extend({}, defaults, options);\n        // parse slideWidth setting\n        slider.settings.slideWidth = parseInt(slider.settings.slideWidth);\n        // store the original children\n        slider.children = el.children(slider.settings.slideSelector);\n        // check if actual number of slides is less than minSlides / maxSlides\n        if (slider.children.length < slider.settings.minSlides) {\n          slider.settings.minSlides = slider.children.length;\n        }\n        if (slider.children.length < slider.settings.maxSlides) {\n          slider.settings.maxSlides = slider.children.length;\n        }\n        // if random start, set the startSlide setting to random number\n        if (slider.settings.randomStart) {\n          slider.settings.startSlide = Math.floor(Math.random() * slider.children.length);\n        }\n        // store active slide information\n        slider.active = { index: slider.settings.startSlide };\n        // store if the slider is in carousel mode (displaying / moving multiple slides)\n        slider.carousel = slider.settings.minSlides > 1 || slider.settings.maxSlides > 1 ? true : false;\n        // if carousel, force preloadImages = 'all'\n        if (slider.carousel) {\n          slider.settings.preloadImages = 'all';\n        }\n        // calculate the min / max width thresholds based on min / max number of slides\n        // used to setup and update carousel slides dimensions\n        slider.minThreshold = slider.settings.minSlides * slider.settings.slideWidth + (slider.settings.minSlides - 1) * slider.settings.slideMargin;\n        slider.maxThreshold = slider.settings.maxSlides * slider.settings.slideWidth + (slider.settings.maxSlides - 1) * slider.settings.slideMargin;\n        // store the current state of the slider (if currently animating, working is true)\n        slider.working = false;\n        // initialize the controls object\n        slider.controls = {};\n        // initialize an auto interval\n        slider.interval = null;\n        // determine which property to use for transitions\n        slider.animProp = slider.settings.mode === 'vertical' ? 'top' : 'left';\n        // determine if hardware acceleration can be used\n        slider.usingCSS = slider.settings.useCSS && slider.settings.mode !== 'fade' && function () {\n          // create our test div element\n          var div = document.createElement('div'),\n\n          // css transition properties\n          props = ['WebkitPerspective', 'MozPerspective', 'OPerspective', 'msPerspective'];\n          // test for each property\n          for (var i = 0; i < props.length; i++) {\n            if (div.style[props[i]] !== undefined) {\n              slider.cssPrefix = props[i].replace('Perspective', '').toLowerCase();\n              slider.animProp = '-' + slider.cssPrefix + '-transform';\n              return true;\n            }\n          }\n          return false;\n        }();\n        // if vertical mode always make maxSlides and minSlides equal\n        if (slider.settings.mode === 'vertical') {\n          slider.settings.maxSlides = slider.settings.minSlides;\n        }\n        // save original style data\n        el.data('origStyle', el.attr('style'));\n        el.children(slider.settings.slideSelector).each(function () {\n          $(this).data('origStyle', $(this).attr('style'));\n        });\n\n        // perform all DOM / CSS modifications\n        setup();\n      };\n\n      /**\r\n       * Performs all DOM and CSS modifications\r\n       */\n      var setup = function setup() {\n        var preloadSelector = slider.children.eq(slider.settings.startSlide); // set the default preload selector (visible)\n\n        // wrap el in a wrapper\n        el.wrap('<div class=\"' + slider.settings.wrapperClass + '\"><div class=\"bx-viewport\"></div></div>');\n        // store a namespace reference to .bx-viewport\n        slider.viewport = el.parent();\n\n        // add aria-live if the setting is enabled and ticker mode is disabled\n        if (slider.settings.ariaLive && !slider.settings.ticker) {\n          slider.viewport.attr('aria-live', 'polite');\n        }\n        // add a loading div to display while images are loading\n        slider.loader = $('<div class=\"bx-loading\" />');\n        slider.viewport.prepend(slider.loader);\n        // set el to a massive width, to hold any needed slides\n        // also strip any margin and padding from el\n        el.css({\n          width: slider.settings.mode === 'horizontal' ? slider.children.length * 1000 + 215 + '%' : 'auto',\n          position: 'relative'\n        });\n        // if using CSS, add the easing property\n        if (slider.usingCSS && slider.settings.easing) {\n          el.css('-' + slider.cssPrefix + '-transition-timing-function', slider.settings.easing);\n          // if not using CSS and no easing value was supplied, use the default JS animation easing (swing)\n        } else if (!slider.settings.easing) {\n          slider.settings.easing = 'swing';\n        }\n        // make modifications to the viewport (.bx-viewport)\n        slider.viewport.css({\n          width: '100%',\n          overflow: 'hidden',\n          position: 'relative'\n        });\n        slider.viewport.parent().css({\n          maxWidth: getViewportMaxWidth()\n        });\n        // apply css to all slider children\n        slider.children.css({\n          float: slider.settings.mode === 'horizontal' ? 'left' : 'none',\n          listStyle: 'none',\n          position: 'relative'\n        });\n        // apply the calculated width after the float is applied to prevent scrollbar interference\n        slider.children.css('width', getSlideWidth());\n        // if slideMargin is supplied, add the css\n        if (slider.settings.mode === 'horizontal' && slider.settings.slideMargin > 0) {\n          slider.children.css('marginRight', slider.settings.slideMargin);\n        }\n        if (slider.settings.mode === 'vertical' && slider.settings.slideMargin > 0) {\n          slider.children.css('marginBottom', slider.settings.slideMargin);\n        }\n        // if \"fade\" mode, add positioning and z-index CSS\n        if (slider.settings.mode === 'fade') {\n          slider.children.css({\n            position: 'absolute',\n            zIndex: 0,\n            display: 'none'\n          });\n          // prepare the z-index on the showing element\n          slider.children.eq(slider.settings.startSlide).css({ zIndex: slider.settings.slideZIndex, display: 'block' });\n        }\n        // create an element to contain all slider controls (pager, start / stop, etc)\n        slider.controls.el = $('<div class=\"bx-controls\" />');\n        // if captions are requested, add them\n        if (slider.settings.captions) {\n          appendCaptions();\n        }\n        // check if startSlide is last slide\n        slider.active.last = slider.settings.startSlide === getPagerQty() - 1;\n        // if video is true, set up the fitVids plugin\n        if (slider.settings.video) {\n          el.fitVids();\n        }\n        if (slider.settings.preloadImages === 'all' || slider.settings.ticker) {\n          preloadSelector = slider.children;\n        }\n        // only check for control addition if not in \"ticker\" mode\n        if (!slider.settings.ticker) {\n          // if controls are requested, add them\n          if (slider.settings.controls) {\n            appendControls();\n          }\n          // if auto is true, and auto controls are requested, add them\n          if (slider.settings.auto && slider.settings.autoControls) {\n            appendControlsAuto();\n          }\n          // if pager is requested, add it\n          if (slider.settings.pager) {\n            appendPager();\n          }\n          // if any control option is requested, add the controls wrapper\n          if (slider.settings.controls || slider.settings.autoControls || slider.settings.pager) {\n            slider.viewport.after(slider.controls.el);\n          }\n          // if ticker mode, do not allow a pager\n        } else {\n          slider.settings.pager = false;\n        }\n        loadElements(preloadSelector, start);\n      };\n\n      var loadElements = function loadElements(selector, callback) {\n        var total = selector.find('img:not([src=\"\"]), iframe').length,\n            count = 0;\n        if (total === 0) {\n          callback();\n          return;\n        }\n        selector.find('img:not([src=\"\"]), iframe').each(function () {\n          $(this).one('load error', function () {\n            if (++count === total) {\n              callback();\n            }\n          }).each(function () {\n            if (this.complete) {\n              $(this).trigger('load');\n            }\n          });\n        });\n      };\n\n      /**\r\n       * Start the slider\r\n       */\n      var start = function start() {\n        // if infinite loop, prepare additional slides\n        if (slider.settings.infiniteLoop && slider.settings.mode !== 'fade' && !slider.settings.ticker) {\n          var slice = slider.settings.mode === 'vertical' ? slider.settings.minSlides : slider.settings.maxSlides,\n              sliceAppend = slider.children.slice(0, slice).clone(true).addClass('bx-clone'),\n              slicePrepend = slider.children.slice(-slice).clone(true).addClass('bx-clone');\n          if (slider.settings.ariaHidden) {\n            sliceAppend.attr('aria-hidden', true);\n            slicePrepend.attr('aria-hidden', true);\n          }\n          el.append(sliceAppend).prepend(slicePrepend);\n        }\n        // remove the loading DOM element\n        slider.loader.remove();\n        // set the left / top position of \"el\"\n        setSlidePosition();\n        // if \"vertical\" mode, always use adaptiveHeight to prevent odd behavior\n        if (slider.settings.mode === 'vertical') {\n          slider.settings.adaptiveHeight = true;\n        }\n        // set the viewport height\n        slider.viewport.height(getViewportHeight());\n        // make sure everything is positioned just right (same as a window resize)\n        el.redrawSlider();\n        // onSliderLoad callback\n        slider.settings.onSliderLoad.call(el, slider.active.index);\n        // slider has been fully initialized\n        slider.initialized = true;\n        // bind the resize call to the window\n        if (slider.settings.responsive) {\n          $(window).bind('resize', resizeWindow);\n        }\n        // if auto is true and has more than 1 page, start the show\n        if (slider.settings.auto && slider.settings.autoStart && (getPagerQty() > 1 || slider.settings.autoSlideForOnePage)) {\n          initAuto();\n        }\n        // if ticker is true, start the ticker\n        if (slider.settings.ticker) {\n          initTicker();\n        }\n        // if pager is requested, make the appropriate pager link active\n        if (slider.settings.pager) {\n          updatePagerActive(slider.settings.startSlide);\n        }\n        // check for any updates to the controls (like hideControlOnEnd updates)\n        if (slider.settings.controls) {\n          updateDirectionControls();\n        }\n        // if touchEnabled is true, setup the touch events\n        if (slider.settings.touchEnabled && !slider.settings.ticker) {\n          initTouch();\n        }\n        // if keyboardEnabled is true, setup the keyboard events\n        if (slider.settings.keyboardEnabled && !slider.settings.ticker) {\n          $(document).keydown(keyPress);\n        }\n      };\n\n      /**\r\n       * Returns the calculated height of the viewport, used to determine either adaptiveHeight or the maxHeight value\r\n       */\n      var getViewportHeight = function getViewportHeight() {\n        var height = 0;\n        // first determine which children (slides) should be used in our height calculation\n        var children = $();\n        // if mode is not \"vertical\" and adaptiveHeight is false, include all children\n        if (slider.settings.mode !== 'vertical' && !slider.settings.adaptiveHeight) {\n          children = slider.children;\n        } else {\n          // if not carousel, return the single active child\n          if (!slider.carousel) {\n            children = slider.children.eq(slider.active.index);\n            // if carousel, return a slice of children\n          } else {\n            // get the individual slide index\n            var currentIndex = slider.settings.moveSlides === 1 ? slider.active.index : slider.active.index * getMoveBy();\n            // add the current slide to the children\n            children = slider.children.eq(currentIndex);\n            // cycle through the remaining \"showing\" slides\n            for (i = 1; i <= slider.settings.maxSlides - 1; i++) {\n              // if looped back to the start\n              if (currentIndex + i >= slider.children.length) {\n                children = children.add(slider.children.eq(i - 1));\n              } else {\n                children = children.add(slider.children.eq(currentIndex + i));\n              }\n            }\n          }\n        }\n        // if \"vertical\" mode, calculate the sum of the heights of the children\n        if (slider.settings.mode === 'vertical') {\n          children.each(function (index) {\n            height += $(this).outerHeight();\n          });\n          // add user-supplied margins\n          if (slider.settings.slideMargin > 0) {\n            height += slider.settings.slideMargin * (slider.settings.minSlides - 1);\n          }\n          // if not \"vertical\" mode, calculate the max height of the children\n        } else {\n          height = Math.max.apply(Math, children.map(function () {\n            return $(this).outerHeight(false);\n          }).get());\n        }\n\n        if (slider.viewport.css('box-sizing') === 'border-box') {\n          height += parseFloat(slider.viewport.css('padding-top')) + parseFloat(slider.viewport.css('padding-bottom')) + parseFloat(slider.viewport.css('border-top-width')) + parseFloat(slider.viewport.css('border-bottom-width'));\n        } else if (slider.viewport.css('box-sizing') === 'padding-box') {\n          height += parseFloat(slider.viewport.css('padding-top')) + parseFloat(slider.viewport.css('padding-bottom'));\n        }\n\n        return height;\n      };\n\n      /**\r\n       * Returns the calculated width to be used for the outer wrapper / viewport\r\n       */\n      var getViewportMaxWidth = function getViewportMaxWidth() {\n        var width = '100%';\n        if (slider.settings.slideWidth > 0) {\n          if (slider.settings.mode === 'horizontal') {\n            width = slider.settings.maxSlides * slider.settings.slideWidth + (slider.settings.maxSlides - 1) * slider.settings.slideMargin;\n          } else {\n            width = slider.settings.slideWidth;\n          }\n        }\n        return width;\n      };\n\n      /**\r\n       * Returns the calculated width to be applied to each slide\r\n       */\n      var getSlideWidth = function getSlideWidth() {\n        var newElWidth = slider.settings.slideWidth,\n            // start with any user-supplied slide width\n        wrapWidth = slider.viewport.width(); // get the current viewport width\n        // if slide width was not supplied, or is larger than the viewport use the viewport width\n        if (slider.settings.slideWidth === 0 || slider.settings.slideWidth > wrapWidth && !slider.carousel || slider.settings.mode === 'vertical') {\n          newElWidth = wrapWidth;\n          // if carousel, use the thresholds to determine the width\n        } else if (slider.settings.maxSlides > 1 && slider.settings.mode === 'horizontal') {\n          if (wrapWidth > slider.maxThreshold) {\n            return newElWidth;\n          } else if (wrapWidth < slider.minThreshold) {\n            newElWidth = (wrapWidth - slider.settings.slideMargin * (slider.settings.minSlides - 1)) / slider.settings.minSlides;\n          } else if (slider.settings.shrinkItems) {\n            newElWidth = Math.floor((wrapWidth + slider.settings.slideMargin) / Math.ceil((wrapWidth + slider.settings.slideMargin) / (newElWidth + slider.settings.slideMargin)) - slider.settings.slideMargin);\n          }\n        }\n        return newElWidth;\n      };\n\n      /**\r\n       * Returns the number of slides currently visible in the viewport (includes partially visible slides)\r\n       */\n      var getNumberSlidesShowing = function getNumberSlidesShowing() {\n        var slidesShowing = 1,\n            childWidth = null;\n        if (slider.settings.mode === 'horizontal' && slider.settings.slideWidth > 0) {\n          // if viewport is smaller than minThreshold, return minSlides\n          if (slider.viewport.width() < slider.minThreshold) {\n            slidesShowing = slider.settings.minSlides;\n            // if viewport is larger than maxThreshold, return maxSlides\n          } else if (slider.viewport.width() > slider.maxThreshold) {\n            slidesShowing = slider.settings.maxSlides;\n            // if viewport is between min / max thresholds, divide viewport width by first child width\n          } else {\n            childWidth = slider.children.first().width() + slider.settings.slideMargin;\n            slidesShowing = Math.floor((slider.viewport.width() + slider.settings.slideMargin) / childWidth);\n          }\n          // if \"vertical\" mode, slides showing will always be minSlides\n        } else if (slider.settings.mode === 'vertical') {\n          slidesShowing = slider.settings.minSlides;\n        }\n        return slidesShowing;\n      };\n\n      /**\r\n       * Returns the number of pages (one full viewport of slides is one \"page\")\r\n       */\n      var getPagerQty = function getPagerQty() {\n        var pagerQty = 0,\n            breakPoint = 0,\n            counter = 0;\n        // if moveSlides is specified by the user\n        if (slider.settings.moveSlides > 0) {\n          if (slider.settings.infiniteLoop) {\n            pagerQty = Math.ceil(slider.children.length / getMoveBy());\n          } else {\n            // when breakpoint goes above children length, counter is the number of pages\n            while (breakPoint < slider.children.length) {\n              ++pagerQty;\n              breakPoint = counter + getNumberSlidesShowing();\n              counter += slider.settings.moveSlides <= getNumberSlidesShowing() ? slider.settings.moveSlides : getNumberSlidesShowing();\n            }\n          }\n          // if moveSlides is 0 (auto) divide children length by sides showing, then round up\n        } else {\n          pagerQty = Math.ceil(slider.children.length / getNumberSlidesShowing());\n        }\n        return pagerQty;\n      };\n\n      /**\r\n       * Returns the number of individual slides by which to shift the slider\r\n       */\n      var getMoveBy = function getMoveBy() {\n        // if moveSlides was set by the user and moveSlides is less than number of slides showing\n        if (slider.settings.moveSlides > 0 && slider.settings.moveSlides <= getNumberSlidesShowing()) {\n          return slider.settings.moveSlides;\n        }\n        // if moveSlides is 0 (auto)\n        return getNumberSlidesShowing();\n      };\n\n      /**\r\n       * Sets the slider's (el) left or top position\r\n       */\n      var setSlidePosition = function setSlidePosition() {\n        var position, lastChild, lastShowingIndex;\n        // if last slide, not infinite loop, and number of children is larger than specified maxSlides\n        if (slider.children.length > slider.settings.maxSlides && slider.active.last && !slider.settings.infiniteLoop) {\n          if (slider.settings.mode === 'horizontal') {\n            // get the last child's position\n            lastChild = slider.children.last();\n            position = lastChild.position();\n            // set the left position\n            setPositionProperty(-(position.left - (slider.viewport.width() - lastChild.outerWidth())), 'reset', 0);\n          } else if (slider.settings.mode === 'vertical') {\n            // get the last showing index's position\n            lastShowingIndex = slider.children.length - slider.settings.minSlides;\n            position = slider.children.eq(lastShowingIndex).position();\n            // set the top position\n            setPositionProperty(-position.top, 'reset', 0);\n          }\n          // if not last slide\n        } else {\n          // get the position of the first showing slide\n          position = slider.children.eq(slider.active.index * getMoveBy()).position();\n          // check for last slide\n          if (slider.active.index === getPagerQty() - 1) {\n            slider.active.last = true;\n          }\n          // set the respective position\n          if (position !== undefined) {\n            if (slider.settings.mode === 'horizontal') {\n              setPositionProperty(-position.left, 'reset', 0);\n            } else if (slider.settings.mode === 'vertical') {\n              setPositionProperty(-position.top, 'reset', 0);\n            }\n          }\n        }\n      };\n\n      /**\r\n       * Sets the el's animating property position (which in turn will sometimes animate el).\r\n       * If using CSS, sets the transform property. If not using CSS, sets the top / left property.\r\n       *\r\n       * @param value (int)\r\n       *  - the animating property's value\r\n       *\r\n       * @param type (string) 'slide', 'reset', 'ticker'\r\n       *  - the type of instance for which the function is being\r\n       *\r\n       * @param duration (int)\r\n       *  - the amount of time (in ms) the transition should occupy\r\n       *\r\n       * @param params (array) optional\r\n       *  - an optional parameter containing any variables that need to be passed in\r\n       */\n      var setPositionProperty = function setPositionProperty(value, type, duration, params) {\n        var animateObj, propValue;\n        // use CSS transform\n        if (slider.usingCSS) {\n          // determine the translate3d value\n          propValue = slider.settings.mode === 'vertical' ? 'translate3d(0, ' + value + 'px, 0)' : 'translate3d(' + value + 'px, 0, 0)';\n          // add the CSS transition-duration\n          el.css('-' + slider.cssPrefix + '-transition-duration', duration / 1000 + 's');\n          if (type === 'slide') {\n            // set the property value\n            el.css(slider.animProp, propValue);\n            if (duration !== 0) {\n              // bind a callback method - executes when CSS transition completes\n              el.bind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', function (e) {\n                //make sure it's the correct one\n                if (!$(e.target).is(el)) {\n                  return;\n                }\n                // unbind the callback\n                el.unbind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd');\n                updateAfterSlideTransition();\n              });\n            } else {\n              //duration = 0\n              updateAfterSlideTransition();\n            }\n          } else if (type === 'reset') {\n            el.css(slider.animProp, propValue);\n          } else if (type === 'ticker') {\n            // make the transition use 'linear'\n            el.css('-' + slider.cssPrefix + '-transition-timing-function', 'linear');\n            el.css(slider.animProp, propValue);\n            if (duration !== 0) {\n              el.bind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', function (e) {\n                //make sure it's the correct one\n                if (!$(e.target).is(el)) {\n                  return;\n                }\n                // unbind the callback\n                el.unbind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd');\n                // reset the position\n                setPositionProperty(params.resetValue, 'reset', 0);\n                // start the loop again\n                tickerLoop();\n              });\n            } else {\n              //duration = 0\n              setPositionProperty(params.resetValue, 'reset', 0);\n              tickerLoop();\n            }\n          }\n          // use JS animate\n        } else {\n          animateObj = {};\n          animateObj[slider.animProp] = value;\n          if (type === 'slide') {\n            el.animate(animateObj, duration, slider.settings.easing, function () {\n              updateAfterSlideTransition();\n            });\n          } else if (type === 'reset') {\n            el.css(slider.animProp, value);\n          } else if (type === 'ticker') {\n            el.animate(animateObj, duration, 'linear', function () {\n              setPositionProperty(params.resetValue, 'reset', 0);\n              // run the recursive loop after animation\n              tickerLoop();\n            });\n          }\n        }\n      };\n\n      /**\r\n       * Populates the pager with proper amount of pages\r\n       */\n      var populatePager = function populatePager() {\n        var pagerHtml = '',\n            linkContent = '',\n            pagerQty = getPagerQty();\n        // loop through each pager item\n        for (var i = 0; i < pagerQty; i++) {\n          linkContent = '';\n          // if a buildPager function is supplied, use it to get pager link value, else use index + 1\n          if (slider.settings.buildPager && $.isFunction(slider.settings.buildPager) || slider.settings.pagerCustom) {\n            linkContent = slider.settings.buildPager(i);\n            slider.pagerEl.addClass('bx-custom-pager');\n          } else {\n            linkContent = i + 1;\n            slider.pagerEl.addClass('bx-default-pager');\n          }\n          // var linkContent = slider.settings.buildPager && $.isFunction(slider.settings.buildPager) ? slider.settings.buildPager(i) : i + 1;\n          // add the markup to the string\n          pagerHtml += '<div class=\"bx-pager-item\"><a href=\"\" data-slide-index=\"' + i + '\" class=\"bx-pager-link\">' + linkContent + '</a></div>';\n        }\n        // populate the pager element with pager links\n        slider.pagerEl.html(pagerHtml);\n      };\n\n      /**\r\n       * Appends the pager to the controls element\r\n       */\n      var appendPager = function appendPager() {\n        if (!slider.settings.pagerCustom) {\n          // create the pager DOM element\n          slider.pagerEl = $('<div class=\"bx-pager\" />');\n          // if a pager selector was supplied, populate it with the pager\n          if (slider.settings.pagerSelector) {\n            $(slider.settings.pagerSelector).html(slider.pagerEl);\n            // if no pager selector was supplied, add it after the wrapper\n          } else {\n            slider.controls.el.addClass('bx-has-pager').append(slider.pagerEl);\n          }\n          // populate the pager\n          populatePager();\n        } else {\n          slider.pagerEl = $(slider.settings.pagerCustom);\n        }\n        // assign the pager click binding\n        slider.pagerEl.on('click touchend', 'a', clickPagerBind);\n      };\n\n      /**\r\n       * Appends prev / next controls to the controls element\r\n       */\n      var appendControls = function appendControls() {\n        slider.controls.next = $('<a class=\"bx-next\" href=\"\">' + slider.settings.nextText + '</a>');\n        slider.controls.prev = $('<a class=\"bx-prev\" href=\"\">' + slider.settings.prevText + '</a>');\n        // bind click actions to the controls\n        slider.controls.next.bind('click touchend', clickNextBind);\n        slider.controls.prev.bind('click touchend', clickPrevBind);\n        // if nextSelector was supplied, populate it\n        if (slider.settings.nextSelector) {\n          $(slider.settings.nextSelector).append(slider.controls.next);\n        }\n        // if prevSelector was supplied, populate it\n        if (slider.settings.prevSelector) {\n          $(slider.settings.prevSelector).append(slider.controls.prev);\n        }\n        // if no custom selectors were supplied\n        if (!slider.settings.nextSelector && !slider.settings.prevSelector) {\n          // add the controls to the DOM\n          slider.controls.directionEl = $('<div class=\"bx-controls-direction\" />');\n          // add the control elements to the directionEl\n          slider.controls.directionEl.append(slider.controls.prev).append(slider.controls.next);\n          // slider.viewport.append(slider.controls.directionEl);\n          slider.controls.el.addClass('bx-has-controls-direction').append(slider.controls.directionEl);\n        }\n      };\n\n      /**\r\n       * Appends start / stop auto controls to the controls element\r\n       */\n      var appendControlsAuto = function appendControlsAuto() {\n        slider.controls.start = $('<div class=\"bx-controls-auto-item\"><a class=\"bx-start\" href=\"\">' + slider.settings.startText + '</a></div>');\n        slider.controls.stop = $('<div class=\"bx-controls-auto-item\"><a class=\"bx-stop\" href=\"\">' + slider.settings.stopText + '</a></div>');\n        // add the controls to the DOM\n        slider.controls.autoEl = $('<div class=\"bx-controls-auto\" />');\n        // bind click actions to the controls\n        slider.controls.autoEl.on('click', '.bx-start', clickStartBind);\n        slider.controls.autoEl.on('click', '.bx-stop', clickStopBind);\n        // if autoControlsCombine, insert only the \"start\" control\n        if (slider.settings.autoControlsCombine) {\n          slider.controls.autoEl.append(slider.controls.start);\n          // if autoControlsCombine is false, insert both controls\n        } else {\n          slider.controls.autoEl.append(slider.controls.start).append(slider.controls.stop);\n        }\n        // if auto controls selector was supplied, populate it with the controls\n        if (slider.settings.autoControlsSelector) {\n          $(slider.settings.autoControlsSelector).html(slider.controls.autoEl);\n          // if auto controls selector was not supplied, add it after the wrapper\n        } else {\n          slider.controls.el.addClass('bx-has-controls-auto').append(slider.controls.autoEl);\n        }\n        // update the auto controls\n        updateAutoControls(slider.settings.autoStart ? 'stop' : 'start');\n      };\n\n      /**\r\n       * Appends image captions to the DOM\r\n       */\n      var appendCaptions = function appendCaptions() {\n        // cycle through each child\n        slider.children.each(function (index) {\n          // get the image title attribute\n          var title = $(this).find('img:first').attr('title');\n          // append the caption\n          if (title !== undefined && ('' + title).length) {\n            $(this).append('<div class=\"bx-caption\"><span>' + title + '</span></div>');\n          }\n        });\n      };\n\n      /**\r\n       * Click next binding\r\n       *\r\n       * @param e (event)\r\n       *  - DOM event object\r\n       */\n      var clickNextBind = function clickNextBind(e) {\n        e.preventDefault();\n        if (slider.controls.el.hasClass('disabled')) {\n          return;\n        }\n        // if auto show is running, stop it\n        if (slider.settings.auto && slider.settings.stopAutoOnClick) {\n          el.stopAuto();\n        }\n        el.goToNextSlide();\n      };\n\n      /**\r\n       * Click prev binding\r\n       *\r\n       * @param e (event)\r\n       *  - DOM event object\r\n       */\n      var clickPrevBind = function clickPrevBind(e) {\n        e.preventDefault();\n        if (slider.controls.el.hasClass('disabled')) {\n          return;\n        }\n        // if auto show is running, stop it\n        if (slider.settings.auto && slider.settings.stopAutoOnClick) {\n          el.stopAuto();\n        }\n        el.goToPrevSlide();\n      };\n\n      /**\r\n       * Click start binding\r\n       *\r\n       * @param e (event)\r\n       *  - DOM event object\r\n       */\n      var clickStartBind = function clickStartBind(e) {\n        el.startAuto();\n        e.preventDefault();\n      };\n\n      /**\r\n       * Click stop binding\r\n       *\r\n       * @param e (event)\r\n       *  - DOM event object\r\n       */\n      var clickStopBind = function clickStopBind(e) {\n        el.stopAuto();\n        e.preventDefault();\n      };\n\n      /**\r\n       * Click pager binding\r\n       *\r\n       * @param e (event)\r\n       *  - DOM event object\r\n       */\n      var clickPagerBind = function clickPagerBind(e) {\n        var pagerLink, pagerIndex;\n        e.preventDefault();\n        if (slider.controls.el.hasClass('disabled')) {\n          return;\n        }\n        // if auto show is running, stop it\n        if (slider.settings.auto && slider.settings.stopAutoOnClick) {\n          el.stopAuto();\n        }\n        pagerLink = $(e.currentTarget);\n        if (pagerLink.attr('data-slide-index') !== undefined) {\n          pagerIndex = parseInt(pagerLink.attr('data-slide-index'));\n          // if clicked pager link is not active, continue with the goToSlide call\n          if (pagerIndex !== slider.active.index) {\n            el.goToSlide(pagerIndex);\n          }\n        }\n      };\n\n      /**\r\n       * Updates the pager links with an active class\r\n       *\r\n       * @param slideIndex (int)\r\n       *  - index of slide to make active\r\n       */\n      var updatePagerActive = function updatePagerActive(slideIndex) {\n        // if \"short\" pager type\n        var len = slider.children.length; // nb of children\n        if (slider.settings.pagerType === 'short') {\n          if (slider.settings.maxSlides > 1) {\n            len = Math.ceil(slider.children.length / slider.settings.maxSlides);\n          }\n          slider.pagerEl.html(slideIndex + 1 + slider.settings.pagerShortSeparator + len);\n          return;\n        }\n        // remove all pager active classes\n        slider.pagerEl.find('a').removeClass('active');\n        // apply the active class for all pagers\n        slider.pagerEl.each(function (i, el) {\n          $(el).find('a').eq(slideIndex).addClass('active');\n        });\n      };\n\n      /**\r\n       * Performs needed actions after a slide transition\r\n       */\n      var updateAfterSlideTransition = function updateAfterSlideTransition() {\n        // if infinite loop is true\n        if (slider.settings.infiniteLoop) {\n          var position = '';\n          // first slide\n          if (slider.active.index === 0) {\n            // set the new position\n            position = slider.children.eq(0).position();\n            // carousel, last slide\n          } else if (slider.active.index === getPagerQty() - 1 && slider.carousel) {\n            position = slider.children.eq((getPagerQty() - 1) * getMoveBy()).position();\n            // last slide\n          } else if (slider.active.index === slider.children.length - 1) {\n            position = slider.children.eq(slider.children.length - 1).position();\n          }\n          if (position) {\n            if (slider.settings.mode === 'horizontal') {\n              setPositionProperty(-position.left, 'reset', 0);\n            } else if (slider.settings.mode === 'vertical') {\n              setPositionProperty(-position.top, 'reset', 0);\n            }\n          }\n        }\n        // declare that the transition is complete\n        slider.working = false;\n        // onSlideAfter callback\n        slider.settings.onSlideAfter.call(el, slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index);\n      };\n\n      /**\r\n       * Updates the auto controls state (either active, or combined switch)\r\n       *\r\n       * @param state (string) \"start\", \"stop\"\r\n       *  - the new state of the auto show\r\n       */\n      var updateAutoControls = function updateAutoControls(state) {\n        // if autoControlsCombine is true, replace the current control with the new state\n        if (slider.settings.autoControlsCombine) {\n          slider.controls.autoEl.html(slider.controls[state]);\n          // if autoControlsCombine is false, apply the \"active\" class to the appropriate control\n        } else {\n          slider.controls.autoEl.find('a').removeClass('active');\n          slider.controls.autoEl.find('a:not(.bx-' + state + ')').addClass('active');\n        }\n      };\n\n      /**\r\n       * Updates the direction controls (checks if either should be hidden)\r\n       */\n      var updateDirectionControls = function updateDirectionControls() {\n        if (getPagerQty() === 1) {\n          slider.controls.prev.addClass('disabled');\n          slider.controls.next.addClass('disabled');\n        } else if (!slider.settings.infiniteLoop && slider.settings.hideControlOnEnd) {\n          // if first slide\n          if (slider.active.index === 0) {\n            slider.controls.prev.addClass('disabled');\n            slider.controls.next.removeClass('disabled');\n            // if last slide\n          } else if (slider.active.index === getPagerQty() - 1) {\n            slider.controls.next.addClass('disabled');\n            slider.controls.prev.removeClass('disabled');\n            // if any slide in the middle\n          } else {\n            slider.controls.prev.removeClass('disabled');\n            slider.controls.next.removeClass('disabled');\n          }\n        }\n      };\n\n      /**\r\n       * Initializes the auto process\r\n       */\n      var initAuto = function initAuto() {\n        // if autoDelay was supplied, launch the auto show using a setTimeout() call\n        if (slider.settings.autoDelay > 0) {\n          var timeout = setTimeout(el.startAuto, slider.settings.autoDelay);\n          // if autoDelay was not supplied, start the auto show normally\n        } else {\n          el.startAuto();\n\n          //add focus and blur events to ensure its running if timeout gets paused\n          $(window).focus(function () {\n            el.startAuto();\n          }).blur(function () {\n            el.stopAuto();\n          });\n        }\n        // if autoHover is requested\n        if (slider.settings.autoHover) {\n          // on el hover\n          el.hover(function () {\n            // if the auto show is currently playing (has an active interval)\n            if (slider.interval) {\n              // stop the auto show and pass true argument which will prevent control update\n              el.stopAuto(true);\n              // create a new autoPaused value which will be used by the relative \"mouseout\" event\n              slider.autoPaused = true;\n            }\n          }, function () {\n            // if the autoPaused value was created be the prior \"mouseover\" event\n            if (slider.autoPaused) {\n              // start the auto show and pass true argument which will prevent control update\n              el.startAuto(true);\n              // reset the autoPaused value\n              slider.autoPaused = null;\n            }\n          });\n        }\n      };\n\n      /**\r\n       * Initializes the ticker process\r\n       */\n      var initTicker = function initTicker() {\n        var startPosition = 0,\n            position,\n            transform,\n            value,\n            idx,\n            ratio,\n            property,\n            newSpeed,\n            totalDimens;\n        // if autoDirection is \"next\", append a clone of the entire slider\n        if (slider.settings.autoDirection === 'next') {\n          el.append(slider.children.clone().addClass('bx-clone'));\n          // if autoDirection is \"prev\", prepend a clone of the entire slider, and set the left position\n        } else {\n          el.prepend(slider.children.clone().addClass('bx-clone'));\n          position = slider.children.first().position();\n          startPosition = slider.settings.mode === 'horizontal' ? -position.left : -position.top;\n        }\n        setPositionProperty(startPosition, 'reset', 0);\n        // do not allow controls in ticker mode\n        slider.settings.pager = false;\n        slider.settings.controls = false;\n        slider.settings.autoControls = false;\n        // if autoHover is requested\n        if (slider.settings.tickerHover) {\n          if (slider.usingCSS) {\n            idx = slider.settings.mode === 'horizontal' ? 4 : 5;\n            slider.viewport.hover(function () {\n              transform = el.css('-' + slider.cssPrefix + '-transform');\n              value = parseFloat(transform.split(',')[idx]);\n              setPositionProperty(value, 'reset', 0);\n            }, function () {\n              totalDimens = 0;\n              slider.children.each(function (index) {\n                totalDimens += slider.settings.mode === 'horizontal' ? $(this).outerWidth(true) : $(this).outerHeight(true);\n              });\n              // calculate the speed ratio (used to determine the new speed to finish the paused animation)\n              ratio = slider.settings.speed / totalDimens;\n              // determine which property to use\n              property = slider.settings.mode === 'horizontal' ? 'left' : 'top';\n              // calculate the new speed\n              newSpeed = ratio * (totalDimens - Math.abs(parseInt(value)));\n              tickerLoop(newSpeed);\n            });\n          } else {\n            // on el hover\n            slider.viewport.hover(function () {\n              el.stop();\n            }, function () {\n              // calculate the total width of children (used to calculate the speed ratio)\n              totalDimens = 0;\n              slider.children.each(function (index) {\n                totalDimens += slider.settings.mode === 'horizontal' ? $(this).outerWidth(true) : $(this).outerHeight(true);\n              });\n              // calculate the speed ratio (used to determine the new speed to finish the paused animation)\n              ratio = slider.settings.speed / totalDimens;\n              // determine which property to use\n              property = slider.settings.mode === 'horizontal' ? 'left' : 'top';\n              // calculate the new speed\n              newSpeed = ratio * (totalDimens - Math.abs(parseInt(el.css(property))));\n              tickerLoop(newSpeed);\n            });\n          }\n        }\n        // start the ticker loop\n        tickerLoop();\n      };\n\n      /**\r\n       * Runs a continuous loop, news ticker-style\r\n       */\n      var tickerLoop = function tickerLoop(resumeSpeed) {\n        var speed = resumeSpeed ? resumeSpeed : slider.settings.speed,\n            position = { left: 0, top: 0 },\n            reset = { left: 0, top: 0 },\n            animateProperty,\n            resetValue,\n            params;\n\n        // if \"next\" animate left position to last child, then reset left to 0\n        if (slider.settings.autoDirection === 'next') {\n          position = el.find('.bx-clone').first().position();\n          // if \"prev\" animate left position to 0, then reset left to first non-clone child\n        } else {\n          reset = slider.children.first().position();\n        }\n        animateProperty = slider.settings.mode === 'horizontal' ? -position.left : -position.top;\n        resetValue = slider.settings.mode === 'horizontal' ? -reset.left : -reset.top;\n        params = { resetValue: resetValue };\n        setPositionProperty(animateProperty, 'ticker', speed, params);\n      };\n\n      /**\r\n       * Check if el is on screen\r\n       */\n      var isOnScreen = function isOnScreen(el) {\n        var win = $(window),\n            viewport = {\n          top: win.scrollTop(),\n          left: win.scrollLeft()\n        },\n            bounds = el.offset();\n\n        viewport.right = viewport.left + win.width();\n        viewport.bottom = viewport.top + win.height();\n        bounds.right = bounds.left + el.outerWidth();\n        bounds.bottom = bounds.top + el.outerHeight();\n\n        return !(viewport.right < bounds.left || viewport.left > bounds.right || viewport.bottom < bounds.top || viewport.top > bounds.bottom);\n      };\n\n      /**\r\n       * Initializes keyboard events\r\n       */\n      var keyPress = function keyPress(e) {\n        var activeElementTag = document.activeElement.tagName.toLowerCase(),\n            tagFilters = 'input|textarea',\n            p = new RegExp(activeElementTag, ['i']),\n            result = p.exec(tagFilters);\n\n        if (result == null && isOnScreen(el)) {\n          if (e.keyCode === 39) {\n            clickNextBind(e);\n            return false;\n          } else if (e.keyCode === 37) {\n            clickPrevBind(e);\n            return false;\n          }\n        }\n      };\n\n      /**\r\n       * Initializes touch events\r\n       */\n      var initTouch = function initTouch() {\n        // initialize object to contain all touch values\n        slider.touch = {\n          start: { x: 0, y: 0 },\n          end: { x: 0, y: 0 }\n        };\n        slider.viewport.bind('touchstart MSPointerDown pointerdown', onTouchStart);\n\n        //for browsers that have implemented pointer events and fire a click after\n        //every pointerup regardless of whether pointerup is on same screen location as pointerdown or not\n        slider.viewport.on('click', '.bxslider a', function (e) {\n          if (slider.viewport.hasClass('click-disabled')) {\n            e.preventDefault();\n            slider.viewport.removeClass('click-disabled');\n          }\n        });\n      };\n\n      /**\r\n       * Event handler for \"touchstart\"\r\n       *\r\n       * @param e (event)\r\n       *  - DOM event object\r\n       */\n      var onTouchStart = function onTouchStart(e) {\n        //disable slider controls while user is interacting with slides to avoid slider freeze that happens on touch devices when a slide swipe happens immediately after interacting with slider controls\n        slider.controls.el.addClass('disabled');\n\n        if (slider.working) {\n          e.preventDefault();\n          slider.controls.el.removeClass('disabled');\n        } else {\n          // record the original position when touch starts\n          slider.touch.originalPos = el.position();\n          var orig = e.originalEvent,\n              touchPoints = typeof orig.changedTouches !== 'undefined' ? orig.changedTouches : [orig];\n          // record the starting touch x, y coordinates\n          slider.touch.start.x = touchPoints[0].pageX;\n          slider.touch.start.y = touchPoints[0].pageY;\n\n          if (slider.viewport.get(0).setPointerCapture) {\n            slider.pointerId = orig.pointerId;\n            slider.viewport.get(0).setPointerCapture(slider.pointerId);\n          }\n          // bind a \"touchmove\" event to the viewport\n          slider.viewport.bind('touchmove MSPointerMove pointermove', onTouchMove);\n          // bind a \"touchend\" event to the viewport\n          slider.viewport.bind('touchend MSPointerUp pointerup', onTouchEnd);\n          slider.viewport.bind('MSPointerCancel pointercancel', onPointerCancel);\n        }\n      };\n\n      /**\r\n       * Cancel Pointer for Windows Phone\r\n       *\r\n       * @param e (event)\r\n       *  - DOM event object\r\n       */\n      var onPointerCancel = function onPointerCancel(e) {\n        /* onPointerCancel handler is needed to deal with situations when a touchend\r\n        doesn't fire after a touchstart (this happens on windows phones only) */\n        setPositionProperty(slider.touch.originalPos.left, 'reset', 0);\n\n        //remove handlers\n        slider.controls.el.removeClass('disabled');\n        slider.viewport.unbind('MSPointerCancel pointercancel', onPointerCancel);\n        slider.viewport.unbind('touchmove MSPointerMove pointermove', onTouchMove);\n        slider.viewport.unbind('touchend MSPointerUp pointerup', onTouchEnd);\n        if (slider.viewport.get(0).releasePointerCapture) {\n          slider.viewport.get(0).releasePointerCapture(slider.pointerId);\n        }\n      };\n\n      /**\r\n       * Event handler for \"touchmove\"\r\n       *\r\n       * @param e (event)\r\n       *  - DOM event object\r\n       */\n      var onTouchMove = function onTouchMove(e) {\n        var orig = e.originalEvent,\n            touchPoints = typeof orig.changedTouches !== 'undefined' ? orig.changedTouches : [orig],\n\n        // if scrolling on y axis, do not prevent default\n        xMovement = Math.abs(touchPoints[0].pageX - slider.touch.start.x),\n            yMovement = Math.abs(touchPoints[0].pageY - slider.touch.start.y),\n            value = 0,\n            change = 0;\n\n        // x axis swipe\n        if (xMovement * 3 > yMovement && slider.settings.preventDefaultSwipeX) {\n          e.preventDefault();\n          // y axis swipe\n        } else if (yMovement * 3 > xMovement && slider.settings.preventDefaultSwipeY) {\n          e.preventDefault();\n        }\n        if (slider.settings.mode !== 'fade' && slider.settings.oneToOneTouch) {\n          // if horizontal, drag along x axis\n          if (slider.settings.mode === 'horizontal') {\n            change = touchPoints[0].pageX - slider.touch.start.x;\n            value = slider.touch.originalPos.left + change;\n            // if vertical, drag along y axis\n          } else {\n            change = touchPoints[0].pageY - slider.touch.start.y;\n            value = slider.touch.originalPos.top + change;\n          }\n          setPositionProperty(value, 'reset', 0);\n        }\n      };\n\n      /**\r\n       * Event handler for \"touchend\"\r\n       *\r\n       * @param e (event)\r\n       *  - DOM event object\r\n       */\n      var onTouchEnd = function onTouchEnd(e) {\n        slider.viewport.unbind('touchmove MSPointerMove pointermove', onTouchMove);\n        //enable slider controls as soon as user stops interacing with slides\n        slider.controls.el.removeClass('disabled');\n        var orig = e.originalEvent,\n            touchPoints = typeof orig.changedTouches !== 'undefined' ? orig.changedTouches : [orig],\n            value = 0,\n            distance = 0;\n        // record end x, y positions\n        slider.touch.end.x = touchPoints[0].pageX;\n        slider.touch.end.y = touchPoints[0].pageY;\n        // if fade mode, check if absolute x distance clears the threshold\n        if (slider.settings.mode === 'fade') {\n          distance = Math.abs(slider.touch.start.x - slider.touch.end.x);\n          if (distance >= slider.settings.swipeThreshold) {\n            if (slider.touch.start.x > slider.touch.end.x) {\n              el.goToNextSlide();\n            } else {\n              el.goToPrevSlide();\n            }\n            el.stopAuto();\n          }\n          // not fade mode\n        } else {\n          // calculate distance and el's animate property\n          if (slider.settings.mode === 'horizontal') {\n            distance = slider.touch.end.x - slider.touch.start.x;\n            value = slider.touch.originalPos.left;\n          } else {\n            distance = slider.touch.end.y - slider.touch.start.y;\n            value = slider.touch.originalPos.top;\n          }\n          // if not infinite loop and first / last slide, do not attempt a slide transition\n          if (!slider.settings.infiniteLoop && (slider.active.index === 0 && distance > 0 || slider.active.last && distance < 0)) {\n            setPositionProperty(value, 'reset', 200);\n          } else {\n            // check if distance clears threshold\n            if (Math.abs(distance) >= slider.settings.swipeThreshold) {\n              if (distance < 0) {\n                el.goToNextSlide();\n              } else {\n                el.goToPrevSlide();\n              }\n              el.stopAuto();\n            } else {\n              // el.animate(property, 200);\n              setPositionProperty(value, 'reset', 200);\n            }\n          }\n        }\n        slider.viewport.unbind('touchend MSPointerUp pointerup', onTouchEnd);\n        if (slider.viewport.get(0).releasePointerCapture) {\n          slider.viewport.get(0).releasePointerCapture(slider.pointerId);\n        }\n      };\n\n      /**\r\n       * Window resize event callback\r\n       */\n      var resizeWindow = function resizeWindow(e) {\n        // don't do anything if slider isn't initialized.\n        if (!slider.initialized) {\n          return;\n        }\n        // Delay if slider working.\n        if (slider.working) {\n          window.setTimeout(resizeWindow, 10);\n        } else {\n          // get the new window dimens (again, thank you IE)\n          var windowWidthNew = $(window).width(),\n              windowHeightNew = $(window).height();\n          // make sure that it is a true window resize\n          // *we must check this because our dinosaur friend IE fires a window resize event when certain DOM elements\n          // are resized. Can you just die already?*\n          if (windowWidth !== windowWidthNew || windowHeight !== windowHeightNew) {\n            // set the new window dimens\n            windowWidth = windowWidthNew;\n            windowHeight = windowHeightNew;\n            // update all dynamic elements\n            el.redrawSlider();\n            // Call user resize handler\n            slider.settings.onSliderResize.call(el, slider.active.index);\n          }\n        }\n      };\n\n      /**\r\n       * Adds an aria-hidden=true attribute to each element\r\n       *\r\n       * @param startVisibleIndex (int)\r\n       *  - the first visible element's index\r\n       */\n      var applyAriaHiddenAttributes = function applyAriaHiddenAttributes(startVisibleIndex) {\n        var numberOfSlidesShowing = getNumberSlidesShowing();\n        // only apply attributes if the setting is enabled and not in ticker mode\n        if (slider.settings.ariaHidden && !slider.settings.ticker) {\n          // add aria-hidden=true to all elements\n          slider.children.attr('aria-hidden', 'true');\n          // get the visible elements and change to aria-hidden=false\n          slider.children.slice(startVisibleIndex, startVisibleIndex + numberOfSlidesShowing).attr('aria-hidden', 'false');\n        }\n      };\n\n      /**\r\n       * Returns index according to present page range\r\n       *\r\n       * @param slideOndex (int)\r\n       *  - the desired slide index\r\n       */\n      var setSlideIndex = function setSlideIndex(slideIndex) {\n        if (slideIndex < 0) {\n          if (slider.settings.infiniteLoop) {\n            return getPagerQty() - 1;\n          } else {\n            //we don't go to undefined slides\n            return slider.active.index;\n          }\n          // if slideIndex is greater than children length, set active index to 0 (this happens during infinite loop)\n        } else if (slideIndex >= getPagerQty()) {\n          if (slider.settings.infiniteLoop) {\n            return 0;\n          } else {\n            //we don't move to undefined pages\n            return slider.active.index;\n          }\n          // set active index to requested slide\n        } else {\n          return slideIndex;\n        }\n      };\n\n      /**\r\n       * ===================================================================================\r\n       * = PUBLIC FUNCTIONS\r\n       * ===================================================================================\r\n       */\n\n      /**\r\n       * Performs slide transition to the specified slide\r\n       *\r\n       * @param slideIndex (int)\r\n       *  - the destination slide's index (zero-based)\r\n       *\r\n       * @param direction (string)\r\n       *  - INTERNAL USE ONLY - the direction of travel (\"prev\" / \"next\")\r\n       */\n      el.goToSlide = function (slideIndex, direction) {\n        // onSlideBefore, onSlideNext, onSlidePrev callbacks\n        // Allow transition canceling based on returned value\n        var performTransition = true,\n            moveBy = 0,\n            position = { left: 0, top: 0 },\n            lastChild = null,\n            lastShowingIndex,\n            eq,\n            value,\n            requestEl;\n        // store the old index\n        slider.oldIndex = slider.active.index;\n        //set new index\n        slider.active.index = setSlideIndex(slideIndex);\n\n        // if plugin is currently in motion, ignore request\n        if (slider.working || slider.active.index === slider.oldIndex) {\n          return;\n        }\n        // declare that plugin is in motion\n        slider.working = true;\n\n        performTransition = slider.settings.onSlideBefore.call(el, slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index);\n\n        // If transitions canceled, reset and return\n        if (typeof performTransition !== 'undefined' && !performTransition) {\n          slider.active.index = slider.oldIndex; // restore old index\n          slider.working = false; // is not in motion\n          return;\n        }\n\n        if (direction === 'next') {\n          // Prevent canceling in future functions or lack there-of from negating previous commands to cancel\n          if (!slider.settings.onSlideNext.call(el, slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index)) {\n            performTransition = false;\n          }\n        } else if (direction === 'prev') {\n          // Prevent canceling in future functions or lack there-of from negating previous commands to cancel\n          if (!slider.settings.onSlidePrev.call(el, slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index)) {\n            performTransition = false;\n          }\n        }\n\n        // check if last slide\n        slider.active.last = slider.active.index >= getPagerQty() - 1;\n        // update the pager with active class\n        if (slider.settings.pager || slider.settings.pagerCustom) {\n          updatePagerActive(slider.active.index);\n        }\n        // // check for direction control update\n        if (slider.settings.controls) {\n          updateDirectionControls();\n        }\n        // if slider is set to mode: \"fade\"\n        if (slider.settings.mode === 'fade') {\n          // if adaptiveHeight is true and next height is different from current height, animate to the new height\n          if (slider.settings.adaptiveHeight && slider.viewport.height() !== getViewportHeight()) {\n            slider.viewport.animate({ height: getViewportHeight() }, slider.settings.adaptiveHeightSpeed);\n          }\n          // fade out the visible child and reset its z-index value\n          slider.children.filter(':visible').fadeOut(slider.settings.speed).css({ zIndex: 0 });\n          // fade in the newly requested slide\n          slider.children.eq(slider.active.index).css('zIndex', slider.settings.slideZIndex + 1).fadeIn(slider.settings.speed, function () {\n            $(this).css('zIndex', slider.settings.slideZIndex);\n            updateAfterSlideTransition();\n          });\n          // slider mode is not \"fade\"\n        } else {\n          // if adaptiveHeight is true and next height is different from current height, animate to the new height\n          if (slider.settings.adaptiveHeight && slider.viewport.height() !== getViewportHeight()) {\n            slider.viewport.animate({ height: getViewportHeight() }, slider.settings.adaptiveHeightSpeed);\n          }\n          // if carousel and not infinite loop\n          if (!slider.settings.infiniteLoop && slider.carousel && slider.active.last) {\n            if (slider.settings.mode === 'horizontal') {\n              // get the last child position\n              lastChild = slider.children.eq(slider.children.length - 1);\n              position = lastChild.position();\n              // calculate the position of the last slide\n              moveBy = slider.viewport.width() - lastChild.outerWidth();\n            } else {\n              // get last showing index position\n              lastShowingIndex = slider.children.length - slider.settings.minSlides;\n              position = slider.children.eq(lastShowingIndex).position();\n            }\n            // horizontal carousel, going previous while on first slide (infiniteLoop mode)\n          } else if (slider.carousel && slider.active.last && direction === 'prev') {\n            // get the last child position\n            eq = slider.settings.moveSlides === 1 ? slider.settings.maxSlides - getMoveBy() : (getPagerQty() - 1) * getMoveBy() - (slider.children.length - slider.settings.maxSlides);\n            lastChild = el.children('.bx-clone').eq(eq);\n            position = lastChild.position();\n            // if infinite loop and \"Next\" is clicked on the last slide\n          } else if (direction === 'next' && slider.active.index === 0) {\n            // get the last clone position\n            position = el.find('> .bx-clone').eq(slider.settings.maxSlides).position();\n            slider.active.last = false;\n            // normal non-zero requests\n          } else if (slideIndex >= 0) {\n            //parseInt is applied to allow floats for slides/page\n            requestEl = slideIndex * parseInt(getMoveBy());\n            position = slider.children.eq(requestEl).position();\n          }\n\n          /* If the position doesn't exist\r\n           * (e.g. if you destroy the slider on a next click),\r\n           * it doesn't throw an error.\r\n           */\n          if (typeof position !== 'undefined') {\n            value = slider.settings.mode === 'horizontal' ? -(position.left - moveBy) : -position.top;\n            // plugin values to be animated\n            setPositionProperty(value, 'slide', slider.settings.speed);\n          } else {\n            slider.working = false;\n          }\n        }\n        if (slider.settings.ariaHidden) {\n          applyAriaHiddenAttributes(slider.active.index * getMoveBy());\n        }\n      };\n\n      /**\r\n       * Transitions to the next slide in the show\r\n       */\n      el.goToNextSlide = function () {\n        // if infiniteLoop is false and last page is showing, disregard call\n        if (!slider.settings.infiniteLoop && slider.active.last) {\n          return;\n        }\n        var pagerIndex = parseInt(slider.active.index) + 1;\n        el.goToSlide(pagerIndex, 'next');\n      };\n\n      /**\r\n       * Transitions to the prev slide in the show\r\n       */\n      el.goToPrevSlide = function () {\n        // if infiniteLoop is false and last page is showing, disregard call\n        if (!slider.settings.infiniteLoop && slider.active.index === 0) {\n          return;\n        }\n        var pagerIndex = parseInt(slider.active.index) - 1;\n        el.goToSlide(pagerIndex, 'prev');\n      };\n\n      /**\r\n       * Starts the auto show\r\n       *\r\n       * @param preventControlUpdate (boolean)\r\n       *  - if true, auto controls state will not be updated\r\n       */\n      el.startAuto = function (preventControlUpdate) {\n        // if an interval already exists, disregard call\n        if (slider.interval) {\n          return;\n        }\n        // create an interval\n        slider.interval = setInterval(function () {\n          if (slider.settings.autoDirection === 'next') {\n            el.goToNextSlide();\n          } else {\n            el.goToPrevSlide();\n          }\n        }, slider.settings.pause);\n        // if auto controls are displayed and preventControlUpdate is not true\n        if (slider.settings.autoControls && preventControlUpdate !== true) {\n          updateAutoControls('stop');\n        }\n      };\n\n      /**\r\n       * Stops the auto show\r\n       *\r\n       * @param preventControlUpdate (boolean)\r\n       *  - if true, auto controls state will not be updated\r\n       */\n      el.stopAuto = function (preventControlUpdate) {\n        // if no interval exists, disregard call\n        if (!slider.interval) {\n          return;\n        }\n        // clear the interval\n        clearInterval(slider.interval);\n        slider.interval = null;\n        // if auto controls are displayed and preventControlUpdate is not true\n        if (slider.settings.autoControls && preventControlUpdate !== true) {\n          updateAutoControls('start');\n        }\n      };\n\n      /**\r\n       * Returns current slide index (zero-based)\r\n       */\n      el.getCurrentSlide = function () {\n        return slider.active.index;\n      };\n\n      /**\r\n       * Returns current slide element\r\n       */\n      el.getCurrentSlideElement = function () {\n        return slider.children.eq(slider.active.index);\n      };\n\n      /**\r\n       * Returns a slide element\r\n       * @param index (int)\r\n       *  - The index (zero-based) of the element you want returned.\r\n       */\n      el.getSlideElement = function (index) {\n        return slider.children.eq(index);\n      };\n\n      /**\r\n       * Returns number of slides in show\r\n       */\n      el.getSlideCount = function () {\n        return slider.children.length;\n      };\n\n      /**\r\n       * Return slider.working variable\r\n       */\n      el.isWorking = function () {\n        return slider.working;\n      };\n\n      /**\r\n       * Update all dynamic slider elements\r\n       */\n      el.redrawSlider = function () {\n        // resize all children in ratio to new screen size\n        slider.children.add(el.find('.bx-clone')).outerWidth(getSlideWidth());\n        // adjust the height\n        slider.viewport.css('height', getViewportHeight());\n        // update the slide position\n        if (!slider.settings.ticker) {\n          setSlidePosition();\n        }\n        // if active.last was true before the screen resize, we want\n        // to keep it last no matter what screen size we end on\n        if (slider.active.last) {\n          slider.active.index = getPagerQty() - 1;\n        }\n        // if the active index (page) no longer exists due to the resize, simply set the index as last\n        if (slider.active.index >= getPagerQty()) {\n          slider.active.last = true;\n        }\n        // if a pager is being displayed and a custom pager is not being used, update it\n        if (slider.settings.pager && !slider.settings.pagerCustom) {\n          populatePager();\n          updatePagerActive(slider.active.index);\n        }\n        if (slider.settings.ariaHidden) {\n          applyAriaHiddenAttributes(slider.active.index * getMoveBy());\n        }\n      };\n\n      /**\r\n       * Destroy the current instance of the slider (revert everything back to original state)\r\n       */\n      el.destroySlider = function () {\n        // don't do anything if slider has already been destroyed\n        if (!slider.initialized) {\n          return;\n        }\n        slider.initialized = false;\n        $('.bx-clone', this).remove();\n        slider.children.each(function () {\n          if ($(this).data('origStyle') !== undefined) {\n            $(this).attr('style', $(this).data('origStyle'));\n          } else {\n            $(this).removeAttr('style');\n          }\n        });\n        if ($(this).data('origStyle') !== undefined) {\n          this.attr('style', $(this).data('origStyle'));\n        } else {\n          $(this).removeAttr('style');\n        }\n        $(this).unwrap().unwrap();\n        if (slider.controls.el) {\n          slider.controls.el.remove();\n        }\n        if (slider.controls.next) {\n          slider.controls.next.remove();\n        }\n        if (slider.controls.prev) {\n          slider.controls.prev.remove();\n        }\n        if (slider.pagerEl && slider.settings.controls && !slider.settings.pagerCustom) {\n          slider.pagerEl.remove();\n        }\n        $('.bx-caption', this).remove();\n        if (slider.controls.autoEl) {\n          slider.controls.autoEl.remove();\n        }\n        clearInterval(slider.interval);\n        if (slider.settings.responsive) {\n          $(window).unbind('resize', resizeWindow);\n        }\n        if (slider.settings.keyboardEnabled) {\n          $(document).unbind('keydown', keyPress);\n        }\n        //remove self reference in data\n        $(this).removeData('bxSlider');\n      };\n\n      /**\r\n       * Reload the slider (revert all DOM changes, and re-initialize)\r\n       */\n      el.reloadSlider = function (settings) {\n        if (settings !== undefined) {\n          options = settings;\n        }\n        el.destroySlider();\n        init();\n        //store reference to self in order to access public functions later\n        $(el).data('bxSlider', this);\n      };\n\n      init();\n\n      $(el).data('bxSlider', this);\n\n      // returns the current jQuery object\n      return this;\n    };\n  })(jQuery);\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/routes/bxslider.js\n// module id = 6\n// module chunks = 0\n\n//# sourceURL=webpack:///./js/routes/bxslider.js?");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_LOCAL_MODULE_1__, __WEBPACK_LOCAL_MODULE_1__factory, __WEBPACK_LOCAL_MODULE_1__module;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_2__;var __WEBPACK_LOCAL_MODULE_3__, __WEBPACK_LOCAL_MODULE_3__factory, __WEBPACK_LOCAL_MODULE_3__module;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_4__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_5__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_6__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*!\r\n * Masonry PACKAGED v4.2.0\r\n * Cascading grid layout library\r\n * http://masonry.desandro.com\r\n * MIT License\r\n * by David DeSandro\r\n */\n\n!function (t, e) {\n   true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = function (i) {\n    return e(t, i);\n  }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : \"object\" == (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) && module.exports ? module.exports = e(t, require(\"jquery\")) : t.jQueryBridget = e(t, t.jQuery);\n}(window, function (t, e) {\n  \"use strict\";\n  function i(i, r, a) {\n    function h(t, e, n) {\n      var o,\n          r = \"$().\" + i + '(\"' + e + '\")';return t.each(function (t, h) {\n        var u = a.data(h, i);if (!u) return void s(i + \" not initialized. Cannot call methods, i.e. \" + r);var d = u[e];if (!d || \"_\" == e.charAt(0)) return void s(r + \" is not a valid method\");var l = d.apply(u, n);o = void 0 === o ? l : o;\n      }), void 0 !== o ? o : t;\n    }function u(t, e) {\n      t.each(function (t, n) {\n        var o = a.data(n, i);o ? (o.option(e), o._init()) : (o = new r(n, e), a.data(n, i, o));\n      });\n    }a = a || e || t.jQuery, a && (r.prototype.option || (r.prototype.option = function (t) {\n      a.isPlainObject(t) && (this.options = a.extend(!0, this.options, t));\n    }), a.fn[i] = function (t) {\n      if (\"string\" == typeof t) {\n        var e = o.call(arguments, 1);return h(this, t, e);\n      }return u(this, t), this;\n    }, n(a));\n  }function n(t) {\n    !t || t && t.bridget || (t.bridget = i);\n  }var o = Array.prototype.slice,\n      r = t.console,\n      s = \"undefined\" == typeof r ? function () {} : function (t) {\n    r.error(t);\n  };return n(e || t.jQuery), i;\n}), function (t, e) {\n   true ? !(__WEBPACK_LOCAL_MODULE_1__factory = (e), (__WEBPACK_LOCAL_MODULE_1__module = { id: \"ev-emitter/ev-emitter\", exports: {}, loaded: false }), __WEBPACK_LOCAL_MODULE_1__ = (typeof __WEBPACK_LOCAL_MODULE_1__factory === 'function' ? (__WEBPACK_LOCAL_MODULE_1__factory.call(__WEBPACK_LOCAL_MODULE_1__module.exports, __webpack_require__, __WEBPACK_LOCAL_MODULE_1__module.exports, __WEBPACK_LOCAL_MODULE_1__module)) : __WEBPACK_LOCAL_MODULE_1__factory), (__WEBPACK_LOCAL_MODULE_1__module.loaded = true), __WEBPACK_LOCAL_MODULE_1__ === undefined && (__WEBPACK_LOCAL_MODULE_1__ = __WEBPACK_LOCAL_MODULE_1__module.exports)) : \"object\" == (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) && module.exports ? module.exports = e() : t.EvEmitter = e();\n}(\"undefined\" != typeof window ? window : this, function () {\n  function t() {}var e = t.prototype;return e.on = function (t, e) {\n    if (t && e) {\n      var i = this._events = this._events || {},\n          n = i[t] = i[t] || [];return -1 == n.indexOf(e) && n.push(e), this;\n    }\n  }, e.once = function (t, e) {\n    if (t && e) {\n      this.on(t, e);var i = this._onceEvents = this._onceEvents || {},\n          n = i[t] = i[t] || {};return n[e] = !0, this;\n    }\n  }, e.off = function (t, e) {\n    var i = this._events && this._events[t];if (i && i.length) {\n      var n = i.indexOf(e);return -1 != n && i.splice(n, 1), this;\n    }\n  }, e.emitEvent = function (t, e) {\n    var i = this._events && this._events[t];if (i && i.length) {\n      var n = 0,\n          o = i[n];e = e || [];for (var r = this._onceEvents && this._onceEvents[t]; o;) {\n        var s = r && r[o];s && (this.off(t, o), delete r[o]), o.apply(this, e), n += s ? 0 : 1, o = i[n];\n      }return this;\n    }\n  }, t;\n}), function (t, e) {\n  \"use strict\";\n   true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_LOCAL_MODULE_2__ = (function () {\n    return e();\n  }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__))) : \"object\" == (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) && module.exports ? module.exports = e() : t.getSize = e();\n}(window, function () {\n  \"use strict\";\n  function t(t) {\n    var e = parseFloat(t),\n        i = -1 == t.indexOf(\"%\") && !isNaN(e);return i && e;\n  }function e() {}function i() {\n    for (var t = { width: 0, height: 0, innerWidth: 0, innerHeight: 0, outerWidth: 0, outerHeight: 0 }, e = 0; u > e; e++) {\n      var i = h[e];t[i] = 0;\n    }return t;\n  }function n(t) {\n    var e = getComputedStyle(t);return e || a(\"Style returned \" + e + \". Are you running this code in a hidden iframe on Firefox? See http://bit.ly/getsizebug1\"), e;\n  }function o() {\n    if (!d) {\n      d = !0;var e = document.createElement(\"div\");e.style.width = \"200px\", e.style.padding = \"1px 2px 3px 4px\", e.style.borderStyle = \"solid\", e.style.borderWidth = \"1px 2px 3px 4px\", e.style.boxSizing = \"border-box\";var i = document.body || document.documentElement;i.appendChild(e);var o = n(e);r.isBoxSizeOuter = s = 200 == t(o.width), i.removeChild(e);\n    }\n  }function r(e) {\n    if (o(), \"string\" == typeof e && (e = document.querySelector(e)), e && \"object\" == (typeof e === \"undefined\" ? \"undefined\" : _typeof(e)) && e.nodeType) {\n      var r = n(e);if (\"none\" == r.display) return i();var a = {};a.width = e.offsetWidth, a.height = e.offsetHeight;for (var d = a.isBorderBox = \"border-box\" == r.boxSizing, l = 0; u > l; l++) {\n        var c = h[l],\n            f = r[c],\n            m = parseFloat(f);a[c] = isNaN(m) ? 0 : m;\n      }var p = a.paddingLeft + a.paddingRight,\n          g = a.paddingTop + a.paddingBottom,\n          y = a.marginLeft + a.marginRight,\n          v = a.marginTop + a.marginBottom,\n          _ = a.borderLeftWidth + a.borderRightWidth,\n          z = a.borderTopWidth + a.borderBottomWidth,\n          E = d && s,\n          b = t(r.width);b !== !1 && (a.width = b + (E ? 0 : p + _));var x = t(r.height);return x !== !1 && (a.height = x + (E ? 0 : g + z)), a.innerWidth = a.width - (p + _), a.innerHeight = a.height - (g + z), a.outerWidth = a.width + y, a.outerHeight = a.height + v, a;\n    }\n  }var s,\n      a = \"undefined\" == typeof console ? e : function (t) {\n    console.error(t);\n  },\n      h = [\"paddingLeft\", \"paddingRight\", \"paddingTop\", \"paddingBottom\", \"marginLeft\", \"marginRight\", \"marginTop\", \"marginBottom\", \"borderLeftWidth\", \"borderRightWidth\", \"borderTopWidth\", \"borderBottomWidth\"],\n      u = h.length,\n      d = !1;return r;\n}), function (t, e) {\n  \"use strict\";\n   true ? !(__WEBPACK_LOCAL_MODULE_3__factory = (e), (__WEBPACK_LOCAL_MODULE_3__module = { id: \"desandro-matches-selector/matches-selector\", exports: {}, loaded: false }), __WEBPACK_LOCAL_MODULE_3__ = (typeof __WEBPACK_LOCAL_MODULE_3__factory === 'function' ? (__WEBPACK_LOCAL_MODULE_3__factory.call(__WEBPACK_LOCAL_MODULE_3__module.exports, __webpack_require__, __WEBPACK_LOCAL_MODULE_3__module.exports, __WEBPACK_LOCAL_MODULE_3__module)) : __WEBPACK_LOCAL_MODULE_3__factory), (__WEBPACK_LOCAL_MODULE_3__module.loaded = true), __WEBPACK_LOCAL_MODULE_3__ === undefined && (__WEBPACK_LOCAL_MODULE_3__ = __WEBPACK_LOCAL_MODULE_3__module.exports)) : \"object\" == (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) && module.exports ? module.exports = e() : t.matchesSelector = e();\n}(window, function () {\n  \"use strict\";\n  var t = function () {\n    var t = window.Element.prototype;if (t.matches) return \"matches\";if (t.matchesSelector) return \"matchesSelector\";for (var e = [\"webkit\", \"moz\", \"ms\", \"o\"], i = 0; i < e.length; i++) {\n      var n = e[i],\n          o = n + \"MatchesSelector\";if (t[o]) return o;\n    }\n  }();return function (e, i) {\n    return e[t](i);\n  };\n}), function (t, e) {\n   true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_3__], __WEBPACK_LOCAL_MODULE_4__ = (function (i) {\n    return e(t, i);\n  }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__))) : \"object\" == (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) && module.exports ? module.exports = e(t, require(\"desandro-matches-selector\")) : t.fizzyUIUtils = e(t, t.matchesSelector);\n}(window, function (t, e) {\n  var i = {};i.extend = function (t, e) {\n    for (var i in e) {\n      t[i] = e[i];\n    }return t;\n  }, i.modulo = function (t, e) {\n    return (t % e + e) % e;\n  }, i.makeArray = function (t) {\n    var e = [];if (Array.isArray(t)) e = t;else if (t && \"object\" == (typeof t === \"undefined\" ? \"undefined\" : _typeof(t)) && \"number\" == typeof t.length) for (var i = 0; i < t.length; i++) {\n      e.push(t[i]);\n    } else e.push(t);return e;\n  }, i.removeFrom = function (t, e) {\n    var i = t.indexOf(e);-1 != i && t.splice(i, 1);\n  }, i.getParent = function (t, i) {\n    for (; t != document.body;) {\n      if (t = t.parentNode, e(t, i)) return t;\n    }\n  }, i.getQueryElement = function (t) {\n    return \"string\" == typeof t ? document.querySelector(t) : t;\n  }, i.handleEvent = function (t) {\n    var e = \"on\" + t.type;this[e] && this[e](t);\n  }, i.filterFindElements = function (t, n) {\n    t = i.makeArray(t);var o = [];return t.forEach(function (t) {\n      if (t instanceof HTMLElement) {\n        if (!n) return void o.push(t);e(t, n) && o.push(t);for (var i = t.querySelectorAll(n), r = 0; r < i.length; r++) {\n          o.push(i[r]);\n        }\n      }\n    }), o;\n  }, i.debounceMethod = function (t, e, i) {\n    var n = t.prototype[e],\n        o = e + \"Timeout\";t.prototype[e] = function () {\n      var t = this[o];t && clearTimeout(t);var e = arguments,\n          r = this;this[o] = setTimeout(function () {\n        n.apply(r, e), delete r[o];\n      }, i || 100);\n    };\n  }, i.docReady = function (t) {\n    var e = document.readyState;\"complete\" == e || \"interactive\" == e ? setTimeout(t) : document.addEventListener(\"DOMContentLoaded\", t);\n  }, i.toDashed = function (t) {\n    return t.replace(/(.)([A-Z])/g, function (t, e, i) {\n      return e + \"-\" + i;\n    }).toLowerCase();\n  };var n = t.console;return i.htmlInit = function (e, o) {\n    i.docReady(function () {\n      var r = i.toDashed(o),\n          s = \"data-\" + r,\n          a = document.querySelectorAll(\"[\" + s + \"]\"),\n          h = document.querySelectorAll(\".js-\" + r),\n          u = i.makeArray(a).concat(i.makeArray(h)),\n          d = s + \"-options\",\n          l = t.jQuery;u.forEach(function (t) {\n        var i,\n            r = t.getAttribute(s) || t.getAttribute(d);try {\n          i = r && JSON.parse(r);\n        } catch (a) {\n          return void (n && n.error(\"Error parsing \" + s + \" on \" + t.className + \": \" + a));\n        }var h = new e(t, i);l && l.data(t, o, h);\n      });\n    });\n  }, i;\n}), function (t, e) {\n   true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_1__, __WEBPACK_LOCAL_MODULE_2__], __WEBPACK_AMD_DEFINE_FACTORY__ = (e),\n\t\t\t\t__WEBPACK_LOCAL_MODULE_5__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__)) : \"object\" == (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) && module.exports ? module.exports = e(require(\"ev-emitter\"), require(\"get-size\")) : (t.Outlayer = {}, t.Outlayer.Item = e(t.EvEmitter, t.getSize));\n}(window, function (t, e) {\n  \"use strict\";\n  function i(t) {\n    for (var e in t) {\n      return !1;\n    }return e = null, !0;\n  }function n(t, e) {\n    t && (this.element = t, this.layout = e, this.position = { x: 0, y: 0 }, this._create());\n  }function o(t) {\n    return t.replace(/([A-Z])/g, function (t) {\n      return \"-\" + t.toLowerCase();\n    });\n  }var r = document.documentElement.style,\n      s = \"string\" == typeof r.transition ? \"transition\" : \"WebkitTransition\",\n      a = \"string\" == typeof r.transform ? \"transform\" : \"WebkitTransform\",\n      h = { WebkitTransition: \"webkitTransitionEnd\", transition: \"transitionend\" }[s],\n      u = { transform: a, transition: s, transitionDuration: s + \"Duration\", transitionProperty: s + \"Property\", transitionDelay: s + \"Delay\" },\n      d = n.prototype = Object.create(t.prototype);d.constructor = n, d._create = function () {\n    this._transn = { ingProperties: {}, clean: {}, onEnd: {} }, this.css({ position: \"absolute\" });\n  }, d.handleEvent = function (t) {\n    var e = \"on\" + t.type;this[e] && this[e](t);\n  }, d.getSize = function () {\n    this.size = e(this.element);\n  }, d.css = function (t) {\n    var e = this.element.style;for (var i in t) {\n      var n = u[i] || i;e[n] = t[i];\n    }\n  }, d.getPosition = function () {\n    var t = getComputedStyle(this.element),\n        e = this.layout._getOption(\"originLeft\"),\n        i = this.layout._getOption(\"originTop\"),\n        n = t[e ? \"left\" : \"right\"],\n        o = t[i ? \"top\" : \"bottom\"],\n        r = this.layout.size,\n        s = -1 != n.indexOf(\"%\") ? parseFloat(n) / 100 * r.width : parseInt(n, 10),\n        a = -1 != o.indexOf(\"%\") ? parseFloat(o) / 100 * r.height : parseInt(o, 10);s = isNaN(s) ? 0 : s, a = isNaN(a) ? 0 : a, s -= e ? r.paddingLeft : r.paddingRight, a -= i ? r.paddingTop : r.paddingBottom, this.position.x = s, this.position.y = a;\n  }, d.layoutPosition = function () {\n    var t = this.layout.size,\n        e = {},\n        i = this.layout._getOption(\"originLeft\"),\n        n = this.layout._getOption(\"originTop\"),\n        o = i ? \"paddingLeft\" : \"paddingRight\",\n        r = i ? \"left\" : \"right\",\n        s = i ? \"right\" : \"left\",\n        a = this.position.x + t[o];e[r] = this.getXValue(a), e[s] = \"\";var h = n ? \"paddingTop\" : \"paddingBottom\",\n        u = n ? \"top\" : \"bottom\",\n        d = n ? \"bottom\" : \"top\",\n        l = this.position.y + t[h];e[u] = this.getYValue(l), e[d] = \"\", this.css(e), this.emitEvent(\"layout\", [this]);\n  }, d.getXValue = function (t) {\n    var e = this.layout._getOption(\"horizontal\");return this.layout.options.percentPosition && !e ? t / this.layout.size.width * 100 + \"%\" : t + \"px\";\n  }, d.getYValue = function (t) {\n    var e = this.layout._getOption(\"horizontal\");return this.layout.options.percentPosition && e ? t / this.layout.size.height * 100 + \"%\" : t + \"px\";\n  }, d._transitionTo = function (t, e) {\n    this.getPosition();var i = this.position.x,\n        n = this.position.y,\n        o = parseInt(t, 10),\n        r = parseInt(e, 10),\n        s = o === this.position.x && r === this.position.y;if (this.setPosition(t, e), s && !this.isTransitioning) return void this.layoutPosition();var a = t - i,\n        h = e - n,\n        u = {};u.transform = this.getTranslate(a, h), this.transition({ to: u, onTransitionEnd: { transform: this.layoutPosition }, isCleaning: !0 });\n  }, d.getTranslate = function (t, e) {\n    var i = this.layout._getOption(\"originLeft\"),\n        n = this.layout._getOption(\"originTop\");return t = i ? t : -t, e = n ? e : -e, \"translate3d(\" + t + \"px, \" + e + \"px, 0)\";\n  }, d.goTo = function (t, e) {\n    this.setPosition(t, e), this.layoutPosition();\n  }, d.moveTo = d._transitionTo, d.setPosition = function (t, e) {\n    this.position.x = parseInt(t, 10), this.position.y = parseInt(e, 10);\n  }, d._nonTransition = function (t) {\n    this.css(t.to), t.isCleaning && this._removeStyles(t.to);for (var e in t.onTransitionEnd) {\n      t.onTransitionEnd[e].call(this);\n    }\n  }, d.transition = function (t) {\n    if (!parseFloat(this.layout.options.transitionDuration)) return void this._nonTransition(t);var e = this._transn;for (var i in t.onTransitionEnd) {\n      e.onEnd[i] = t.onTransitionEnd[i];\n    }for (i in t.to) {\n      e.ingProperties[i] = !0, t.isCleaning && (e.clean[i] = !0);\n    }if (t.from) {\n      this.css(t.from);var n = this.element.offsetHeight;n = null;\n    }this.enableTransition(t.to), this.css(t.to), this.isTransitioning = !0;\n  };var l = \"opacity,\" + o(a);d.enableTransition = function () {\n    if (!this.isTransitioning) {\n      var t = this.layout.options.transitionDuration;t = \"number\" == typeof t ? t + \"ms\" : t, this.css({ transitionProperty: l, transitionDuration: t, transitionDelay: this.staggerDelay || 0 }), this.element.addEventListener(h, this, !1);\n    }\n  }, d.onwebkitTransitionEnd = function (t) {\n    this.ontransitionend(t);\n  }, d.onotransitionend = function (t) {\n    this.ontransitionend(t);\n  };var c = { \"-webkit-transform\": \"transform\" };d.ontransitionend = function (t) {\n    if (t.target === this.element) {\n      var e = this._transn,\n          n = c[t.propertyName] || t.propertyName;if (delete e.ingProperties[n], i(e.ingProperties) && this.disableTransition(), n in e.clean && (this.element.style[t.propertyName] = \"\", delete e.clean[n]), n in e.onEnd) {\n        var o = e.onEnd[n];o.call(this), delete e.onEnd[n];\n      }this.emitEvent(\"transitionEnd\", [this]);\n    }\n  }, d.disableTransition = function () {\n    this.removeTransitionStyles(), this.element.removeEventListener(h, this, !1), this.isTransitioning = !1;\n  }, d._removeStyles = function (t) {\n    var e = {};for (var i in t) {\n      e[i] = \"\";\n    }this.css(e);\n  };var f = { transitionProperty: \"\", transitionDuration: \"\", transitionDelay: \"\" };return d.removeTransitionStyles = function () {\n    this.css(f);\n  }, d.stagger = function (t) {\n    t = isNaN(t) ? 0 : t, this.staggerDelay = t + \"ms\";\n  }, d.removeElem = function () {\n    this.element.parentNode.removeChild(this.element), this.css({ display: \"\" }), this.emitEvent(\"remove\", [this]);\n  }, d.remove = function () {\n    return s && parseFloat(this.layout.options.transitionDuration) ? (this.once(\"transitionEnd\", function () {\n      this.removeElem();\n    }), void this.hide()) : void this.removeElem();\n  }, d.reveal = function () {\n    delete this.isHidden, this.css({ display: \"\" });var t = this.layout.options,\n        e = {},\n        i = this.getHideRevealTransitionEndProperty(\"visibleStyle\");e[i] = this.onRevealTransitionEnd, this.transition({ from: t.hiddenStyle, to: t.visibleStyle, isCleaning: !0, onTransitionEnd: e });\n  }, d.onRevealTransitionEnd = function () {\n    this.isHidden || this.emitEvent(\"reveal\");\n  }, d.getHideRevealTransitionEndProperty = function (t) {\n    var e = this.layout.options[t];if (e.opacity) return \"opacity\";for (var i in e) {\n      return i;\n    }\n  }, d.hide = function () {\n    this.isHidden = !0, this.css({ display: \"\" });var t = this.layout.options,\n        e = {},\n        i = this.getHideRevealTransitionEndProperty(\"hiddenStyle\");e[i] = this.onHideTransitionEnd, this.transition({ from: t.visibleStyle, to: t.hiddenStyle, isCleaning: !0, onTransitionEnd: e });\n  }, d.onHideTransitionEnd = function () {\n    this.isHidden && (this.css({ display: \"none\" }), this.emitEvent(\"hide\"));\n  }, d.destroy = function () {\n    this.css({ position: \"\", left: \"\", right: \"\", top: \"\", bottom: \"\", transition: \"\", transform: \"\" });\n  }, n;\n}), function (t, e) {\n  \"use strict\";\n   true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_1__, __WEBPACK_LOCAL_MODULE_2__, __WEBPACK_LOCAL_MODULE_4__, __WEBPACK_LOCAL_MODULE_5__], __WEBPACK_LOCAL_MODULE_6__ = (function (i, n, o, r) {\n    return e(t, i, n, o, r);\n  }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__))) : \"object\" == (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) && module.exports ? module.exports = e(t, require(\"ev-emitter\"), require(\"get-size\"), require(\"fizzy-ui-utils\"), require(\"./item\")) : t.Outlayer = e(t, t.EvEmitter, t.getSize, t.fizzyUIUtils, t.Outlayer.Item);\n}(window, function (t, e, i, n, o) {\n  \"use strict\";\n  function r(t, e) {\n    var i = n.getQueryElement(t);if (!i) return void (h && h.error(\"Bad element for \" + this.constructor.namespace + \": \" + (i || t)));this.element = i, u && (this.$element = u(this.element)), this.options = n.extend({}, this.constructor.defaults), this.option(e);var o = ++l;this.element.outlayerGUID = o, c[o] = this, this._create();var r = this._getOption(\"initLayout\");r && this.layout();\n  }function s(t) {\n    function e() {\n      t.apply(this, arguments);\n    }return e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e;\n  }function a(t) {\n    if (\"number\" == typeof t) return t;var e = t.match(/(^\\d*\\.?\\d*)(\\w*)/),\n        i = e && e[1],\n        n = e && e[2];if (!i.length) return 0;i = parseFloat(i);var o = m[n] || 1;return i * o;\n  }var h = t.console,\n      u = t.jQuery,\n      d = function d() {},\n      l = 0,\n      c = {};r.namespace = \"outlayer\", r.Item = o, r.defaults = { containerStyle: { position: \"relative\" }, initLayout: !0, originLeft: !0, originTop: !0, resize: !0, resizeContainer: !0, transitionDuration: \"0.4s\", hiddenStyle: { opacity: 0, transform: \"scale(0.001)\" }, visibleStyle: { opacity: 1, transform: \"scale(1)\" } };var f = r.prototype;n.extend(f, e.prototype), f.option = function (t) {\n    n.extend(this.options, t);\n  }, f._getOption = function (t) {\n    var e = this.constructor.compatOptions[t];return e && void 0 !== this.options[e] ? this.options[e] : this.options[t];\n  }, r.compatOptions = { initLayout: \"isInitLayout\", horizontal: \"isHorizontal\", layoutInstant: \"isLayoutInstant\", originLeft: \"isOriginLeft\", originTop: \"isOriginTop\", resize: \"isResizeBound\", resizeContainer: \"isResizingContainer\" }, f._create = function () {\n    this.reloadItems(), this.stamps = [], this.stamp(this.options.stamp), n.extend(this.element.style, this.options.containerStyle);var t = this._getOption(\"resize\");t && this.bindResize();\n  }, f.reloadItems = function () {\n    this.items = this._itemize(this.element.children);\n  }, f._itemize = function (t) {\n    for (var e = this._filterFindItemElements(t), i = this.constructor.Item, n = [], o = 0; o < e.length; o++) {\n      var r = e[o],\n          s = new i(r, this);n.push(s);\n    }return n;\n  }, f._filterFindItemElements = function (t) {\n    return n.filterFindElements(t, this.options.itemSelector);\n  }, f.getItemElements = function () {\n    return this.items.map(function (t) {\n      return t.element;\n    });\n  }, f.layout = function () {\n    this._resetLayout(), this._manageStamps();var t = this._getOption(\"layoutInstant\"),\n        e = void 0 !== t ? t : !this._isLayoutInited;this.layoutItems(this.items, e), this._isLayoutInited = !0;\n  }, f._init = f.layout, f._resetLayout = function () {\n    this.getSize();\n  }, f.getSize = function () {\n    this.size = i(this.element);\n  }, f._getMeasurement = function (t, e) {\n    var n,\n        o = this.options[t];o ? (\"string\" == typeof o ? n = this.element.querySelector(o) : o instanceof HTMLElement && (n = o), this[t] = n ? i(n)[e] : o) : this[t] = 0;\n  }, f.layoutItems = function (t, e) {\n    t = this._getItemsForLayout(t), this._layoutItems(t, e), this._postLayout();\n  }, f._getItemsForLayout = function (t) {\n    return t.filter(function (t) {\n      return !t.isIgnored;\n    });\n  }, f._layoutItems = function (t, e) {\n    if (this._emitCompleteOnItems(\"layout\", t), t && t.length) {\n      var i = [];t.forEach(function (t) {\n        var n = this._getItemLayoutPosition(t);n.item = t, n.isInstant = e || t.isLayoutInstant, i.push(n);\n      }, this), this._processLayoutQueue(i);\n    }\n  }, f._getItemLayoutPosition = function () {\n    return { x: 0, y: 0 };\n  }, f._processLayoutQueue = function (t) {\n    this.updateStagger(), t.forEach(function (t, e) {\n      this._positionItem(t.item, t.x, t.y, t.isInstant, e);\n    }, this);\n  }, f.updateStagger = function () {\n    var t = this.options.stagger;return null === t || void 0 === t ? void (this.stagger = 0) : (this.stagger = a(t), this.stagger);\n  }, f._positionItem = function (t, e, i, n, o) {\n    n ? t.goTo(e, i) : (t.stagger(o * this.stagger), t.moveTo(e, i));\n  }, f._postLayout = function () {\n    this.resizeContainer();\n  }, f.resizeContainer = function () {\n    var t = this._getOption(\"resizeContainer\");if (t) {\n      var e = this._getContainerSize();e && (this._setContainerMeasure(e.width, !0), this._setContainerMeasure(e.height, !1));\n    }\n  }, f._getContainerSize = d, f._setContainerMeasure = function (t, e) {\n    if (void 0 !== t) {\n      var i = this.size;i.isBorderBox && (t += e ? i.paddingLeft + i.paddingRight + i.borderLeftWidth + i.borderRightWidth : i.paddingBottom + i.paddingTop + i.borderTopWidth + i.borderBottomWidth), t = Math.max(t, 0), this.element.style[e ? \"width\" : \"height\"] = t + \"px\";\n    }\n  }, f._emitCompleteOnItems = function (t, e) {\n    function i() {\n      o.dispatchEvent(t + \"Complete\", null, [e]);\n    }function n() {\n      s++, s == r && i();\n    }var o = this,\n        r = e.length;if (!e || !r) return void i();var s = 0;e.forEach(function (e) {\n      e.once(t, n);\n    });\n  }, f.dispatchEvent = function (t, e, i) {\n    var n = e ? [e].concat(i) : i;if (this.emitEvent(t, n), u) if (this.$element = this.$element || u(this.element), e) {\n      var o = u.Event(e);o.type = t, this.$element.trigger(o, i);\n    } else this.$element.trigger(t, i);\n  }, f.ignore = function (t) {\n    var e = this.getItem(t);e && (e.isIgnored = !0);\n  }, f.unignore = function (t) {\n    var e = this.getItem(t);e && delete e.isIgnored;\n  }, f.stamp = function (t) {\n    t = this._find(t), t && (this.stamps = this.stamps.concat(t), t.forEach(this.ignore, this));\n  }, f.unstamp = function (t) {\n    t = this._find(t), t && t.forEach(function (t) {\n      n.removeFrom(this.stamps, t), this.unignore(t);\n    }, this);\n  }, f._find = function (t) {\n    return t ? (\"string\" == typeof t && (t = this.element.querySelectorAll(t)), t = n.makeArray(t)) : void 0;\n  }, f._manageStamps = function () {\n    this.stamps && this.stamps.length && (this._getBoundingRect(), this.stamps.forEach(this._manageStamp, this));\n  }, f._getBoundingRect = function () {\n    var t = this.element.getBoundingClientRect(),\n        e = this.size;this._boundingRect = { left: t.left + e.paddingLeft + e.borderLeftWidth, top: t.top + e.paddingTop + e.borderTopWidth, right: t.right - (e.paddingRight + e.borderRightWidth), bottom: t.bottom - (e.paddingBottom + e.borderBottomWidth) };\n  }, f._manageStamp = d, f._getElementOffset = function (t) {\n    var e = t.getBoundingClientRect(),\n        n = this._boundingRect,\n        o = i(t),\n        r = { left: e.left - n.left - o.marginLeft, top: e.top - n.top - o.marginTop, right: n.right - e.right - o.marginRight, bottom: n.bottom - e.bottom - o.marginBottom };return r;\n  }, f.handleEvent = n.handleEvent, f.bindResize = function () {\n    t.addEventListener(\"resize\", this), this.isResizeBound = !0;\n  }, f.unbindResize = function () {\n    t.removeEventListener(\"resize\", this), this.isResizeBound = !1;\n  }, f.onresize = function () {\n    this.resize();\n  }, n.debounceMethod(r, \"onresize\", 100), f.resize = function () {\n    this.isResizeBound && this.needsResizeLayout() && this.layout();\n  }, f.needsResizeLayout = function () {\n    var t = i(this.element),\n        e = this.size && t;return e && t.innerWidth !== this.size.innerWidth;\n  }, f.addItems = function (t) {\n    var e = this._itemize(t);return e.length && (this.items = this.items.concat(e)), e;\n  }, f.appended = function (t) {\n    var e = this.addItems(t);e.length && (this.layoutItems(e, !0), this.reveal(e));\n  }, f.prepended = function (t) {\n    var e = this._itemize(t);if (e.length) {\n      var i = this.items.slice(0);this.items = e.concat(i), this._resetLayout(), this._manageStamps(), this.layoutItems(e, !0), this.reveal(e), this.layoutItems(i);\n    }\n  }, f.reveal = function (t) {\n    if (this._emitCompleteOnItems(\"reveal\", t), t && t.length) {\n      var e = this.updateStagger();t.forEach(function (t, i) {\n        t.stagger(i * e), t.reveal();\n      });\n    }\n  }, f.hide = function (t) {\n    if (this._emitCompleteOnItems(\"hide\", t), t && t.length) {\n      var e = this.updateStagger();t.forEach(function (t, i) {\n        t.stagger(i * e), t.hide();\n      });\n    }\n  }, f.revealItemElements = function (t) {\n    var e = this.getItems(t);this.reveal(e);\n  }, f.hideItemElements = function (t) {\n    var e = this.getItems(t);this.hide(e);\n  }, f.getItem = function (t) {\n    for (var e = 0; e < this.items.length; e++) {\n      var i = this.items[e];if (i.element == t) return i;\n    }\n  }, f.getItems = function (t) {\n    t = n.makeArray(t);var e = [];return t.forEach(function (t) {\n      var i = this.getItem(t);i && e.push(i);\n    }, this), e;\n  }, f.remove = function (t) {\n    var e = this.getItems(t);this._emitCompleteOnItems(\"remove\", e), e && e.length && e.forEach(function (t) {\n      t.remove(), n.removeFrom(this.items, t);\n    }, this);\n  }, f.destroy = function () {\n    var t = this.element.style;t.height = \"\", t.position = \"\", t.width = \"\", this.items.forEach(function (t) {\n      t.destroy();\n    }), this.unbindResize();var e = this.element.outlayerGUID;delete c[e], delete this.element.outlayerGUID, u && u.removeData(this.element, this.constructor.namespace);\n  }, r.data = function (t) {\n    t = n.getQueryElement(t);var e = t && t.outlayerGUID;return e && c[e];\n  }, r.create = function (t, e) {\n    var i = s(r);return i.defaults = n.extend({}, r.defaults), n.extend(i.defaults, e), i.compatOptions = n.extend({}, r.compatOptions), i.namespace = t, i.data = r.data, i.Item = s(o), n.htmlInit(i, t), u && u.bridget && u.bridget(t, i), i;\n  };var m = { ms: 1, s: 1e3 };return r.Item = o, r;\n}), function (t, e) {\n   true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_6__, __WEBPACK_LOCAL_MODULE_2__], __WEBPACK_AMD_DEFINE_FACTORY__ = (e),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : \"object\" == (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) && module.exports ? module.exports = e(require(\"outlayer\"), require(\"get-size\")) : t.Masonry = e(t.Outlayer, t.getSize);\n}(window, function (t, e) {\n  var i = t.create(\"masonry\");i.compatOptions.fitWidth = \"isFitWidth\";var n = i.prototype;return n._resetLayout = function () {\n    this.getSize(), this._getMeasurement(\"columnWidth\", \"outerWidth\"), this._getMeasurement(\"gutter\", \"outerWidth\"), this.measureColumns(), this.colYs = [];for (var t = 0; t < this.cols; t++) {\n      this.colYs.push(0);\n    }this.maxY = 0, this.horizontalColIndex = 0;\n  }, n.measureColumns = function () {\n    if (this.getContainerWidth(), !this.columnWidth) {\n      var t = this.items[0],\n          i = t && t.element;this.columnWidth = i && e(i).outerWidth || this.containerWidth;\n    }var n = this.columnWidth += this.gutter,\n        o = this.containerWidth + this.gutter,\n        r = o / n,\n        s = n - o % n,\n        a = s && 1 > s ? \"round\" : \"floor\";r = Math[a](r), this.cols = Math.max(r, 1);\n  }, n.getContainerWidth = function () {\n    var t = this._getOption(\"fitWidth\"),\n        i = t ? this.element.parentNode : this.element,\n        n = e(i);this.containerWidth = n && n.innerWidth;\n  }, n._getItemLayoutPosition = function (t) {\n    t.getSize();var e = t.size.outerWidth % this.columnWidth,\n        i = e && 1 > e ? \"round\" : \"ceil\",\n        n = Math[i](t.size.outerWidth / this.columnWidth);n = Math.min(n, this.cols);for (var o = this.options.horizontalOrder ? \"_getHorizontalColPosition\" : \"_getTopColPosition\", r = this[o](n, t), s = { x: this.columnWidth * r.col, y: r.y }, a = r.y + t.size.outerHeight, h = n + r.col, u = r.col; h > u; u++) {\n      this.colYs[u] = a;\n    }return s;\n  }, n._getTopColPosition = function (t) {\n    var e = this._getTopColGroup(t),\n        i = Math.min.apply(Math, e);return { col: e.indexOf(i), y: i };\n  }, n._getTopColGroup = function (t) {\n    if (2 > t) return this.colYs;for (var e = [], i = this.cols + 1 - t, n = 0; i > n; n++) {\n      e[n] = this._getColGroupY(n, t);\n    }return e;\n  }, n._getColGroupY = function (t, e) {\n    if (2 > e) return this.colYs[t];var i = this.colYs.slice(t, t + e);return Math.max.apply(Math, i);\n  }, n._getHorizontalColPosition = function (t, e) {\n    var i = this.horizontalColIndex % this.cols,\n        n = t > 1 && i + t > this.cols;i = n ? 0 : i;var o = e.size.outerWidth && e.size.outerHeight;return this.horizontalColIndex = o ? i + t : this.horizontalColIndex, { col: i, y: this._getColGroupY(i, t) };\n  }, n._manageStamp = function (t) {\n    var i = e(t),\n        n = this._getElementOffset(t),\n        o = this._getOption(\"originLeft\"),\n        r = o ? n.left : n.right,\n        s = r + i.outerWidth,\n        a = Math.floor(r / this.columnWidth);a = Math.max(0, a);var h = Math.floor(s / this.columnWidth);h -= s % this.columnWidth ? 0 : 1, h = Math.min(this.cols - 1, h);for (var u = this._getOption(\"originTop\"), d = (u ? n.top : n.bottom) + i.outerHeight, l = a; h >= l; l++) {\n      this.colYs[l] = Math.max(d, this.colYs[l]);\n    }\n  }, n._getContainerSize = function () {\n    this.maxY = Math.max.apply(Math, this.colYs);var t = { height: this.maxY };return this._getOption(\"fitWidth\") && (t.width = this._getContainerFitWidth()), t;\n  }, n._getContainerFitWidth = function () {\n    for (var t = 0, e = this.cols; --e && 0 === this.colYs[e];) {\n      t++;\n    }return (this.cols - t) * this.columnWidth - this.gutter;\n  }, n.needsResizeLayout = function () {\n    var t = this.containerWidth;return this.getContainerWidth(), t != this.containerWidth;\n  }, i;\n});\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/routes/masonry.pkgd.min.js\n// module id = 7\n// module chunks = 0\n\n//# sourceURL=webpack:///./js/routes/masonry.pkgd.min.js?");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n//Server start\n\nvar $ServerData = {\n    id: 100,\n    data: [{\n        id: 104,\n        name: \"Bradley\",\n        surname: \"Hunter\",\n        photo: 'img/partners--hunter__mobile.png',\n        info: \"Based in Chicago. I love playing tennis and loud music.\",\n        colorIcon: '4e73db',\n        icon: 'img/partners--airplane.svg'\n    }, {\n        id: 102,\n        name: \"Lucas\",\n        surname: \"Marsha\",\n        photo: 'img/partners--marsha__mobile.png',\n        info: \"I get my inspiration from nature and objects around me. I have a passion to colours, typography and skateboards.\",\n        colorIcon: 'ffa507',\n        icon: 'img/partners--flask.svg'\n    }, {\n        id: 103,\n        name: \"Heather\",\n        surname: \"Walker\",\n        photo: 'img/partners--walker__mobile.png',\n        info: \"I'm a happy person that loves cats and climbing on mountains.\",\n        colorIcon: '1cd7ad',\n        icon: 'img/partners--cup.svg'\n    }, {\n        id: 101,\n        name: \"Gogas\",\n        surname: \"Hunter\",\n        photo: 'img/partners--hunter2__mobile.png',\n        info: \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore \",\n        colorIcon: 'ff4e50',\n        icon: 'img/partners--tv.svg'\n    }]\n};\nvar $server = JSON.stringify($ServerData);\n//Server end\n\nmodule.exports = $server;\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/routes/server.js\n// module id = 8\n// module chunks = 0\n\n//# sourceURL=webpack:///./js/routes/server.js?");

/***/ }),
/* 9 */
/***/ (function(module, exports) {

eval("var $templateScript = '<%' + 'var $array = $data.data;' + 'for (let i = 0; i < $array.length; i++) {%>' + '<div class=\"partners--template\">' + '<div class=\"partners--photo\" style=\"background-image:url(<%=$array[i].photo%>)\">' + '<div class=\"partners--embl\" style=\"background-image:url(<%=$array[i].icon%>);background-color:#<%=$array[i].colorIcon%>\"></div>' + '</div>' + '<p class=\"partners--name\"><%=$array[i].name%> <%=$array[i].surname%></p>' + '<p class=\"partners--text\"><%=$array[i].info%></p>' + '</div>' + '<%}%>';\n\nmodule.exports = $templateScript;\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/routes/templateScript.js\n// module id = 9\n// module chunks = 0\n\n//# sourceURL=webpack:///./js/routes/templateScript.js?");

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__routes_myscript__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__routes_myscript___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__routes_myscript__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__routes_pixabay__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__routes_pixabay___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__routes_pixabay__);\n\n\n\n\n\n__webpack_require__(0);\n__webpack_require__(4);\n\n// import accordion from './no_routes/accordion'\n//\n\n\n__WEBPACK_IMPORTED_MODULE_0__routes_myscript___default()();\n__WEBPACK_IMPORTED_MODULE_1__routes_pixabay___default()();\n\n// accordion();\n\n\n// $('.accordion').on('click', '.accordion-panel, .accordion-plus', function(e) {\n//     require.ensure([], function(require) {\n//         let accordion = require('./no_routes/accordion');\n//         // exports.accordion = accordion;\n//         accordion(e);\n//     }, 'accord'); // если несколько эншуров будет иметь однинаковый 3 параметр, в данном случае 'accord'  то они объеденятся в 1 сборку с именем 'accord'\n// });\n\n\n// let scss = require('./../style/syle')\n\n// import '../style/syle';\n\n//======\n// let moduleName = location.pathname.slice(1);\n// let route = require(\"./routes/\" + moduleName); // автоматическая подгрузка модулей с указанной директорииб вместо забитых руками выше каждый в отдельности, будет искать во всех поддиректориях\n// если надо только 1 папка без поддерикторий\n// let context = require.context('./routes/', false, /\\.js$/); // 1 - имя нашей папки,2 - нам не нужны поддериктории потому false. 3 - параметром можно указать регулярное выражениеб что б по например по расширению отфильтровать нужные файлы\n// let route = context('./' + moduleName); // автоматически подгружаем модули\n// route();\n//========\n\n// let moduleName = location.pathname.slice(1);\n// require('bundle!./routes/' + moduleName)(function(route) {\n//\n//     route();\n//\n// }); // не забываем установить npm i bundle-loader\n\n// let moduleName = location.pathname.slice(1);\n// let handler;\n// try {\n//     let context = require.context('bundle!./routes/', true, /^\\.\\//);\n//     handler = context('./' + moduleName);\n// } catch (e) {\n//     alert('No such path');\n// }\n//\n// if (handler) {\n//     handler(function(route) {\n//         route();\n//     });\n// }\n\n// UglifyJSPlugin();\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/script.js\n// module id = 10\n// module chunks = 0\n\n//# sourceURL=webpack:///./js/script.js?");

/***/ })
],[10]);